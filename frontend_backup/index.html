<!-- Author: 16@Xinqwq -->
<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>青云之志 算分器</title>
    <link rel="icon" href="src/assets/16.ico" />
    <style>
      :root{
        --bg:#F2F2F0;        
        --text:#3F3F3A;      
        --muted:#7C7C75;     
        --card:#FFFFFF;      
        --line:#E1E1DC;      
        --primary:#9AA3A0;  
        --primary-strong:#6F7976;
        --accent:#C4B7A6;    
        --accent-light:rgba(196, 183, 166, 0.1);  /* 浅色强调 */
        --accent-hover:rgba(196, 183, 166, 0.2);  /* 悬停强调 */
        --ok:#B7D0C5;        
        --warn:#E3C9A8;      
        --danger:#D9B8B6;    
        --radius:10px;
        --gap:0px;
        /* 次数列样式变量 */
        --count-cell-bg:rgba(154, 163, 160, 0.1);
        --count-cell-border:rgba(154, 163, 160, 0.3);
        --count-cell-text:#3F3F3A;
        --count-cell-hover-bg:rgba(154, 163, 160, 0.15);
      }
      
      /* 配色方案 */
      .theme-16QwQ {
        --bg:#F0F8FF; --text:#2C3E50; --muted:#7F8C8D; --card:#FFFFFF; --line:#D5DBDB;
        --primary:#73CCFF; --primary-strong:#5BB3FF; --accent:#ACF06D; --accent-light:rgba(172, 240, 109, 0.1); --accent-hover:rgba(172, 240, 109, 0.2); --ok:#E8A469; --warn:#F0DF6D; --danger:#AC9076;
        --count-cell-bg:rgba(115, 204, 255, 0.1); --count-cell-border:rgba(115, 204, 255, 0.3); --count-cell-text:#2C3E50; --count-cell-hover-bg:rgba(115, 204, 255, 0.15);
      }
      .theme-buxingshx {
        --bg:#F0FFF0; --text:#2F4F2F; --muted:#696969; --card:#FFFFFF; --line:#DCDCDC;
        --primary:#00E874; --primary-strong:#00CC66; --accent:#00B0F0; --accent-light:rgba(0, 176, 240, 0.1); --accent-hover:rgba(0, 176, 240, 0.2); --ok:#B6FF47; --warn:#EEFF00; --danger:#FF6B6B;
        --count-cell-bg:rgba(0, 232, 116, 0.1); --count-cell-border:rgba(0, 232, 116, 0.3); --count-cell-text:#2F4F2F; --count-cell-hover-bg:rgba(0, 232, 116, 0.15);
      }
      .theme-life {
        --bg:#F8F9FF; --text:#4A4A6A; --muted:#8A8A9A; --card:#FFFFFF; --line:#E8E8F0;
        --primary:#A5EAFF; --primary-strong:#8DD8FF; --accent:#9EC4F6; --accent-light:rgba(158, 196, 246, 0.1); --accent-hover:rgba(158, 196, 246, 0.2); --ok:#BEFFF8; --warn:#E1DCFC; --danger:#D2C0F9;
        --count-cell-bg:rgba(165, 234, 255, 0.1); --count-cell-border:rgba(165, 234, 255, 0.3); --count-cell-text:#4A4A6A; --count-cell-hover-bg:rgba(165, 234, 255, 0.15);
      }
      .theme-purple {
        --bg:#F5FFF5; --text:#2F4F2F; --muted:#696969; --card:#FFFFFF; --line:#E0E0E0;
        --primary:#65BFBE; --primary-strong:#4A9B9A; --accent:#DEEDA1; --accent-light:rgba(222, 237, 161, 0.1); --accent-hover:rgba(222, 237, 161, 0.2); --ok:#BDE031; --warn:#FFF200; --danger:#008F75;
        --count-cell-bg:rgba(101, 191, 190, 0.1); --count-cell-border:rgba(101, 191, 190, 0.3); --count-cell-text:#2F4F2F; --count-cell-hover-bg:rgba(101, 191, 190, 0.15);
      }
      .theme-rainbow {
        --bg:#FFF8F0; --text:#4A3C2A; --muted:#8A7A6A; --card:#FFFFFF; --line:#F0E0D0;
        --primary:#FFB78C; --primary-strong:#FFA066; --accent:#FFF08C; --accent-light:rgba(255, 240, 140, 0.1); --accent-hover:rgba(255, 240, 140, 0.2); --ok:#BBFF8C; --warn:#8CFFCE; --danger:#BD8CFF;
        --count-cell-bg:rgba(255, 183, 140, 0.1); --count-cell-border:rgba(255, 183, 140, 0.3); --count-cell-text:#4A3C2A; --count-cell-hover-bg:rgba(255, 183, 140, 0.15);
      }
      .theme-wonderful {
        --bg:#191A1E; --text:#968d8d; --muted:#c25252; --card:#c9c9d8; --line:#FF3B3E;
        --primary:#FF3B3E; --primary-strong:#E03437; --accent:#FF8657; --accent-light:rgba(255, 134, 87, 0.1); --accent-hover:rgba(255, 134, 87, 0.2); --ok:#FFBA70; --warn:#FF8657; --danger:#FF3B3E;
        --count-cell-bg:rgba(255, 59, 62, 0.1); --count-cell-border:rgba(255, 59, 62, 0.3); --count-cell-text:#968d8d; --count-cell-hover-bg:rgba(255, 59, 62, 0.15);
      }
      .theme-16yyds {
        --bg:#E5FD56; --text:#2D3A1A; --muted:#779149; --card:#f6ffc1; --line:#C6DC74;
        --primary:#95a3f3; --primary-strong:#D1F33A; --accent:#C6DC74; --accent-light:rgba(198, 220, 116, 0.1); --accent-hover:rgba(198, 220, 116, 0.2); --ok:#A8BB92; --warn:#899AB0; --danger:#6A79CE;
        --count-cell-bg:rgba(149, 163, 243, 0.1); --count-cell-border:rgba(149, 163, 243, 0.3); --count-cell-text:#2D3A1A; --count-cell-hover-bg:rgba(149, 163, 243, 0.15);
      }
      
      .theme-selector {
        display: flex; gap: 8px; margin-bottom: 16px; flex-wrap: wrap;
      }
      .theme-option {
        display: flex; align-items: center; gap: 6px; padding: 6px 10px; 
        border: 2px solid var(--line); border-radius: 20px; cursor: pointer; 
        transition: all 0.2s; font-size: 12px; background: var(--card);
      }
      .theme-option:hover { border-color: var(--primary); }
      .theme-option.active { border-color: var(--primary); background: var(--primary); color: white; }
      .theme-colors {
        display: flex; gap: 3px;
      }
      .theme-color {
        width: 12px; height: 12px; border-radius: 50%; border: 1px solid rgba(0,0,0,0.1);
      }
      
      /* 数字输入按钮样式 */
      .number-input-group {
        display: flex;
        align-items: center;
        gap: 4px;
      }
      .number-btn {
        width: 24px; height: 24px;
        border: 1px solid var(--line);
        background: var(--card);
        border-radius: 4px;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        font-size: 14px;
        font-weight: bold;
        color: var(--text);
        transition: all 0.15s;
      }
      .number-btn:hover {
        background: var(--primary);
        color: white;
        border-color: var(--primary);
      }
      .number-input-group input[type="number"] {
        flex: 1;
        text-align: center;
        padding: 4px 6px;
        font-size: 12px;
      }
      
      /* 配置区块样式 */
      .config-block {
        background: var(--card);
        border: 1px solid var(--line);
        border-radius: 8px;
        padding: 12px;
        min-height: 200px;
        position: relative;
      }
      .config-block h4 {
        margin: 0 0 12px 0;
        font-size: 14px;
        color: var(--text);
        border-bottom: 1px solid var(--line);
        padding-bottom: 6px;
        display: flex;
        justify-content: space-between;
        align-items: center;
        cursor: pointer;
      }
      .config-block .block-toggle {
        font-size: 16px;
        font-weight: bold;
        color: var(--muted);
        transition: transform 0.2s;
        margin-left: 8px;
      }
      .config-block.collapsed .block-toggle {
        transform: rotate(-90deg);
      }
      
      /* 区块选择器样式 */
      .block-selector {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        margin-bottom: 16px;
        padding: 12px;
        background: transparent;
        border: none;
        border-radius: 8px;
      }
      .block-btn {
        padding: 6px 12px;
        border: 1px solid var(--line);
        background: var(--card);
        color: var(--text);
        border-radius: 6px;
        font-size: 12px;
        cursor: pointer;
        transition: all 0.2s;
        white-space: nowrap;
      }
      .block-btn:hover {
        background: var(--primary);
        color: white;
        border-color: var(--primary);
      }
      .block-btn.active {
        background: var(--primary);
        color: white;
        border-color: var(--primary);
      }
      .block-btn.active:hover {
        background: var(--primary-strong);
        border-color: var(--primary-strong);
      }
      
      /* 隐藏/显示区块 */
      .config-block.hidden {
        display: none;
      }
      
      /* 精度按钮样式 */
      .precision-buttons {
        display: flex;
        gap: 4px;
      }
      .precision-btn {
        padding: 4px 12px;
        border: 1px solid var(--line);
        background: var(--card);
        color: var(--text);
        border-radius: 4px;
        font-size: 12px;
        cursor: pointer;
        transition: all 0.2s;
      }
      .precision-btn:hover {
        background: var(--primary);
        color: white;
        border-color: var(--primary);
      }
      .precision-btn.active {
        background: var(--primary);
        color: white;
        border-color: var(--primary);
      }
      .config-block .block-content {
        transition: all 0.3s ease;
        overflow: hidden;
      }
      .config-block.collapsed .block-content {
        max-height: 0;
        opacity: 0;
        margin-top: 0;
      }
      .config-block .block-content.expanded {
        max-height: none;
        opacity: 1;
      }
      
      /* 统一input和label布局 */
      .config-block label {
        display: flex;
        align-items: center;
        gap: 8px;
        margin-bottom: 8px;
        font-size: 12px;
        color: var(--text);
      }
      .config-block label > * {
        flex-shrink: 0;
      }
      .config-block label input,
      .config-block label select {
        flex: 1;
        min-width: 0;
      }
      
      /* 数据小助手样式 */
      .data-helper {
        background: var(--card);
        border: 1px solid var(--line);
        border-radius: 8px;
        padding: 12px;
        margin-bottom: 16px;
      }
      .data-helper h4 {
        margin: 0 0 12px 0;
        font-size: 14px;
        color: var(--text);
        border-bottom: 1px solid var(--line);
        padding-bottom: 6px;
      }
      .data-table {
        font-size: 11px;
        max-height: 200px;
        overflow-y: auto;
        border: 1px solid var(--line);
        border-radius: 4px;
      }
      .data-table table {
        width: 100%;
        border-collapse: collapse;
      }
      .data-table th,
      .data-table td {
        padding: 4px 6px;
        text-align: center;
        border-bottom: 1px solid var(--line);
      }
      .data-table th {
        background: var(--accent);
        font-weight: 600;
        color: var(--text);
        position: sticky;
        top: 0;
      }
      .data-table td {
        color: var(--text);
      }
      
      /* 未来关卡预测作为子模块的样式适配 */
      .config-block[data-block="predict"] .card-header {
        background: transparent; border: none; padding: 0; margin: 0 0 8px 0;
      }
      .config-block[data-block="predict"] .card-header h4 {
        margin: 0; font-size: 14px; color: var(--text);
      }
      .config-block[data-block="predict"] .card-header .card-toggle {
        padding: 2px 6px; font-size: 12px; border-radius: 4px; color: var(--muted);
      }
      .config-block[data-block="predict"] .card-content {
        padding: 0; border: none; background: transparent; margin-top: 8px;
      }
      .config-block[data-block="predict"] #currentLevelInfo {
        margin-bottom: 8px; padding: 10px; border-radius: 6px;
      }
      /* 内部两列结果面板的卡片化外观，缩小边距与圆角 */
      .config-block[data-block="predict"] .card-content > div[style*="flex"] > div {
        border: 1px solid var(--line); border-radius: 6px; padding: 10px; background: var(--card);
      }
      .config-block[data-block="predict"] .card-content h5,
      .config-block[data-block="predict"] .card-content h4 {
        margin: 0 0 8px 0; font-size: 13px; color: var(--text);
      }
      .config-block[data-block="predict"] #predBreakdown {
        gap: 12px;
      }
      /* 预测模块按钮：椭圆按钮外观 */
      .config-block[data-block="predict"] #updatePrediction {
        font-size: 11px; padding: 6px 14px; line-height: 1;
        border-radius: 999px; border: 1px solid var(--line);
        background: var(--primary); color: #fff;
      }
      .config-block[data-block="predict"] #updatePrediction:hover { background: var(--primary-strong); }

      /* 特定区块的表格不使用滚动条 */
      .config-block[data-block="display"] .data-table,
      .config-block[data-block="tech"] .data-table {
        max-height: none;
        overflow-y: visible;
      }
      
      /* 商店刷新星币区块显示12行数据 */
      .config-block[data-block="shop"] .data-table {
        max-height: 300px; /* 12行 × 30px/行 = 360px */
        overflow-y: auto;
      }
      .data-table tr:hover {
        background: rgba(154, 163, 160, 0.1);
      }
      
      /* 统一表格样式：大数字单位系统对照表的"单位"列、商店刷新星币的"刷新次数"列、魂牌模块的"次数"列 */
      .config-block[data-block="display"] .data-table tbody td:first-child,
      .config-block[data-block="shop"] .data-table tbody td:first-child,
      .config-block[data-block="tech"] .data-table tbody .count-cell {
        background: var(--accent-light, rgba(154, 163, 160, 0.1));
        font-weight: 500;
        color: var(--text);
      }
      
      /* 统一悬停效果 */
      .config-block[data-block="display"] .data-table tr:hover td:first-child,
      .config-block[data-block="shop"] .data-table tr:hover td:first-child,
      .config-block[data-block="tech"] .data-table tr:hover .count-cell {
        background: var(--accent-hover, rgba(154, 163, 160, 0.2));
      }
      
      .number-input-group input[type="number"] {
        width: 50px; padding: 4px 6px; text-align: center;
        border: 1px solid var(--line); border-radius: 4px;
        font-size: 12px;
      }
      
      /* 配置区块样式 */
      .config-block {
        padding: 12px; border: 1px solid var(--line); border-radius: 8px;
        background: var(--card);
        position: relative;
      }
      .resize-handle {
        position: absolute; top: 0; bottom: 0; width: 6px; cursor: ew-resize; opacity: 0.2;
      }
      .resize-handle.left { left: -3px; }
      .resize-handle.right { right: -3px; }
      .resize-handle:hover { opacity: 0.5; }
      .config-block h4 {
        margin: 0 0 12px 0; font-size: 14px; color: var(--text);
        border-bottom: 1px solid var(--line); padding-bottom: 6px;
      }
      /* 指定子模块去除标题分割线 */
      .config-block[data-block="level-select"] h4,
      .config-block[data-block="predict"] h4 { border-bottom: none; padding-bottom: 0; margin-bottom: 8px; }
      
      /* 轮播提示框 */
      .tips-carousel {
        background: var(--card);
        border: 1px solid var(--line);
        border-radius: 50px;
        padding: 12px 16px;
        margin: 16px 0;
        min-height: 60px;
        display: flex;
        align-items: center;
        position: relative;
        overflow: hidden;
      }
      .tips-carousel::before {
        content: '💡';
        font-size: 18px;
        margin-right: 8px;
        flex-shrink: 0;
      }
      .tips-content {
        flex: 1;
        font-size: 14px;
        color: var(--text);
        line-height: 1.4;
        opacity: 0;
        transform: translateX(20px);
        transition: all 0.5s ease;
      }
      .tips-content.active {
        opacity: 1;
        transform: translateX(0);
      }
      .tips-dots {
        position: absolute;
        bottom: 8px;
        right: 12px;
        display: flex;
        gap: 4px;
      }
      .tips-dot {
        width: 6px;
        height: 6px;
        border-radius: 50%;
        background: var(--muted);
        cursor: pointer;
        transition: background 0.3s;
      }
      .tips-dot.active {
        background: var(--primary);
      }
      
      /* 彩蛋模态框 */
      .modal {
        display: none;
        position: fixed;
        z-index: 1000;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0,0,0,0.5);
      }
      .modal-content {
        background-color: #fefefe;
        margin: 10% auto;
        padding: 20px;
        border-radius: 10px;
        width: 90%;
        max-width: 500px;
        text-align: center;
        box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        display: flex;
        flex-direction: column;
        gap: 15px;
      }
      .modal h2 {
        color: #FF3B3E;
        margin: 0;
      }
      .modal p {
        color: #333;
        margin: 0;
        line-height: 1.5;
      }
      .modal button {
        background: #FF3B3E;
        color: white;
        border: none;
        padding: 10px 20px;
        border-radius: 5px;
        cursor: pointer;
        font-size: 14px;
        align-self: center;
      }
      .modal button:hover {
        background: #E03437;
      }
      *{ box-sizing:border-box }
      body { background:var(--bg); color:var(--text); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "PingFang SC", "Microsoft YaHei", sans-serif; margin: 20px; }
      h1,h3{ margin:0 0 10px 0; font-weight:600 }
      .card { background:var(--card); border: 1px solid var(--line); border-radius: var(--radius); padding: 14px; box-shadow: 0 1px 0 rgba(0,0,0,0.02); position: relative; }
      .card-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }
      .card-toggle { background: none; border: none; color: var(--muted); cursor: pointer; font-size: 14px; padding: 4px 8px; border-radius: 4px; transition: all 0.2s; }
      .card-toggle:hover { background: var(--line); color: var(--text); }
      .card-content { transition: all 0.3s ease; overflow: hidden; }
      .card-content.collapsed { max-height: 0; opacity: 0; margin: 0; padding: 0; }
      /* 在展开时允许内容溢出可见，防止右侧被裁剪 */
      #config-content { overflow: visible; }
      #config-content.collapsed { overflow: hidden; }
      label { display: block; font-size: 12px; color: var(--muted); margin-top: 8px; }
      input, select { width: 100%; padding: 9px 10px; border: 1px solid var(--line); border-radius: 8px; font-size: 14px; background:#FAFAF8; color:var(--text); outline:none }
      input:focus, select:focus{ border-color: var(--primary); box-shadow: 0 0 0 3px rgba(154,163,160,0.15) }
      input:disabled { opacity: 0.5; cursor: not-allowed; }
      input[readonly] { 
        background-color: #f8f9fa; 
        border-color: #e9ecef; 
        cursor: not-allowed; 
        opacity: 0.8;
      }
      button { padding: 9px 14px; border-radius: 999px; border: 1px solid var(--line); background: var(--primary); color: white; cursor: pointer; transition:.15s }
      button:hover{ background: var(--primary-strong) }
      .btn-light{ background:#F5F5F3; color:var(--text) }
      .btn-group { display: flex; gap: 8px; flex-wrap: wrap; }
      .btn-radio { padding: 10px 14px; border: 1px solid var(--line); border-radius: 999px; background: #F6F6F4; color: var(--text); cursor: pointer; transition:.15s; font-size:13px }
      .btn-radio.active { background: var(--primary); color: #fff; border-color: var(--primary); }
      .tag-d, .tag-f, .tag-y { background: #F6F6F4; color: var(--text); border-color: var(--line); }
      .tag-d.alt, .tag-f.alt, .tag-y.alt { background: #F6F6F4; color: var(--text); }
      .tag-d.selected, .tag-f.selected, .tag-y.selected { background: var(--primary); color: #fff; border-color: var(--primary); }
      .tag-d.alt.selected, .tag-f.alt.selected, .tag-y.alt.selected { background: var(--primary); color: #fff; }
      .fill-toggle{ display:flex; align-items:center; gap:8px; font-size:12px; color:var(--muted); margin-bottom:8px; }
      .status { padding: 6px 10px; border-radius: 999px; display: inline-block; border:1px solid var(--line); background:#F8F8F6 }
      .under { background: var(--danger); color: #5E3B3A; }
      .ok { background: var(--warn); color: #6B4F2F; }
      .over5x { background: var(--ok); color: #2C5146; }
      .grid-2 { display:grid; grid-template-columns:repeat(2,1fr); gap:12px; }
      .grid-3 { display:grid; grid-template-columns:repeat(3,1fr); gap:12px; }
      .grid-4 { display:grid; grid-template-columns:repeat(4,1fr); gap:12px; }
      .kv{ display:flex; justify-content:space-between; gap:10px; padding:6px 0; border-bottom:1px dashed var(--line) }
      .kv small{ color:var(--muted) }
      
      /* Lolipop动画样式 - 20种动画效果 */
      @keyframes lolipop-bounce {
        0%, 100% { transform: translateY(0px) rotate(0deg); }
        25% { transform: translateY(-8px) rotate(5deg); }
        50% { transform: translateY(-12px) rotate(0deg); }
        75% { transform: translateY(-6px) rotate(-3deg); }
      }
      
      @keyframes lolipop-spin {
        0% { transform: rotate(0deg) scale(1); }
        25% { transform: rotate(90deg) scale(1.1); }
        50% { transform: rotate(180deg) scale(1); }
        75% { transform: rotate(270deg) scale(0.9); }
        100% { transform: rotate(360deg) scale(1); }
      }
      
      @keyframes lolipop-wiggle {
        0%, 100% { transform: rotate(0deg); }
        25% { transform: rotate(15deg); }
        50% { transform: rotate(-10deg); }
        75% { transform: rotate(8deg); }
      }
      
      @keyframes lolipop-pulse {
        0%, 100% { transform: scale(1); opacity: 0.7; }
        50% { transform: scale(1.2); opacity: 1; }
      }
      
      @keyframes lolipop-float {
        0%, 100% { transform: translateY(0px) translateX(0px); }
        25% { transform: translateY(-5px) translateX(3px); }
        50% { transform: translateY(-10px) translateX(0px); }
        75% { transform: translateY(-5px) translateX(-3px); }
      }
      
      @keyframes lolipop-shake {
        0%, 100% { transform: translateX(0); }
        10% { transform: translateX(-5px) rotate(-1deg); }
        20% { transform: translateX(5px) rotate(1deg); }
        30% { transform: translateX(-3px) rotate(-1deg); }
        40% { transform: translateX(3px) rotate(1deg); }
        50% { transform: translateX(-2px) rotate(-1deg); }
        60% { transform: translateX(2px) rotate(1deg); }
        70% { transform: translateX(-1px) rotate(-1deg); }
        80% { transform: translateX(1px) rotate(1deg); }
        90% { transform: translateX(-1px) rotate(-1deg); }
      }
      
      @keyframes lolipop-zoom {
        0%, 100% { transform: scale(1) rotate(0deg); }
        25% { transform: scale(1.3) rotate(5deg); }
        50% { transform: scale(0.8) rotate(-5deg); }
        75% { transform: scale(1.1) rotate(3deg); }
      }
      
      @keyframes lolipop-swing {
        0%, 100% { transform: rotate(0deg); transform-origin: top center; }
        25% { transform: rotate(15deg); }
        50% { transform: rotate(-10deg); }
        75% { transform: rotate(8deg); }
      }
      
      @keyframes lolipop-flip {
        0% { transform: rotateY(0deg) scale(1); }
        25% { transform: rotateY(90deg) scale(1.1); }
        50% { transform: rotateY(180deg) scale(0.9); }
        75% { transform: rotateY(270deg) scale(1.05); }
        100% { transform: rotateY(360deg) scale(1); }
      }
      
      @keyframes lolipop-dance {
        0%, 100% { transform: translateY(0px) rotate(0deg) scale(1); }
        20% { transform: translateY(-10px) rotate(10deg) scale(1.1); }
        40% { transform: translateY(0px) rotate(-5deg) scale(0.9); }
        60% { transform: translateY(-8px) rotate(-10deg) scale(1.05); }
        80% { transform: translateY(-5px) rotate(5deg) scale(0.95); }
      }
      
      @keyframes lolipop-twist {
        0%, 100% { transform: rotate(0deg) scaleX(1); }
        25% { transform: rotate(45deg) scaleX(0.8); }
        50% { transform: rotate(90deg) scaleX(1.2); }
        75% { transform: rotate(135deg) scaleX(0.9); }
      }
      
      @keyframes lolipop-jump {
        0%, 100% { transform: translateY(0px); }
        50% { transform: translateY(-15px); }
      }
      
      @keyframes lolipop-rock {
        0%, 100% { transform: rotate(0deg) translateY(0px); }
        25% { transform: rotate(5deg) translateY(-3px); }
        50% { transform: rotate(0deg) translateY(0px); }
        75% { transform: rotate(-5deg) translateY(-3px); }
      }
      
      @keyframes lolipop-glide {
        0% { transform: translateX(-20px) rotate(0deg); opacity: 0.5; }
        50% { transform: translateX(0px) rotate(180deg); opacity: 1; }
        100% { transform: translateX(20px) rotate(360deg); opacity: 0.5; }
      }
      
      @keyframes lolipop-squeeze {
        0%, 100% { transform: scaleX(1) scaleY(1); }
        25% { transform: scaleX(1.2) scaleY(0.8); }
        50% { transform: scaleX(0.8) scaleY(1.2); }
        75% { transform: scaleX(1.1) scaleY(0.9); }
      }
      
      @keyframes lolipop-roll {
        0% { transform: translateX(-10px) rotate(0deg); }
        25% { transform: translateX(-5px) rotate(90deg); }
        50% { transform: translateX(0px) rotate(180deg); }
        75% { transform: translateX(5px) rotate(270deg); }
        100% { transform: translateX(10px) rotate(360deg); }
      }
      
      @keyframes lolipop-wave {
        0%, 100% { transform: rotate(0deg) translateY(0px); }
        25% { transform: rotate(10deg) translateY(-5px); }
        50% { transform: rotate(0deg) translateY(-8px); }
        75% { transform: rotate(-10deg) translateY(-5px); }
      }
      
      @keyframes lolipop-bob {
        0%, 100% { transform: translateY(0px) scale(1); }
        50% { transform: translateY(-8px) scale(1.05); }
      }
      
      @keyframes lolipop-sway {
        0%, 100% { transform: rotate(0deg) translateX(0px); }
        33% { transform: rotate(8deg) translateX(5px); }
        66% { transform: rotate(-8deg) translateX(-5px); }
      }
      
      @keyframes lolipop-elastic {
        0%, 100% { transform: scale(1); }
        10% { transform: scale(1.3); }
        20% { transform: scale(0.9); }
        30% { transform: scale(1.1); }
        40% { transform: scale(0.95); }
        50% { transform: scale(1.05); }
        60% { transform: scale(0.98); }
        70% { transform: scale(1.02); }
        80% { transform: scale(0.99); }
        90% { transform: scale(1.01); }
      }
      
      /* 悬浮窗样式 */
      .floating-window {
        position: fixed;
        top: 120px;
        right: auto;
        width: auto;
        min-width: 400px;
        max-width: 90vw;
        min-height: auto;
        max-height: 80vh;
        background: var(--card);
        border: 2px solid var(--primary);
        border-radius: var(--radius);
        box-shadow: 0 8px 32px rgba(0,0,0,0.15);
        z-index: 1000;
        cursor: move;
        user-select: none;
        transition: all 0.3s ease;
      }
      
      .floating-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 8px 12px;
        background: var(--primary);
        color: white;
        border-radius: var(--radius) var(--radius) 0 0;
        cursor: move;
        user-select: none;
      }
      .floating-title {
        font-weight: 600;
        font-size: 14px;
      }
      .floating-controls {
        display: flex;
        gap: 4px;
      }
      .floating-close {
        width: 20px;
        height: 20px;
        border: none;
        background: rgba(255,255,255,0.2);
        color: white;
        border-radius: 3px;
        cursor: pointer;
        font-size: 12px;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: background 0.2s;
      }
      .floating-close:hover {
        background: rgba(255,255,255,0.3);
      }
      .floating-close:hover {
        background: #ff4444;
      }
      
      .floating-content {
        padding: 16px;
        max-height: 400px;
        overflow-y: auto;
      }
      
      /* 开关样式 */
      .result-toggle {
        display: flex;
        align-items: center;
      }
      .toggle-switch {
        display: flex;
        align-items: center;
        gap: 8px;
        cursor: pointer;
        font-size: 14px;
        color: var(--text);
      }
      .toggle-switch input[type="checkbox"] {
        display: none;
      }
      .toggle-slider {
        width: 50px;
        height: 24px;
        background: #ccc;
        border-radius: 12px;
        position: relative;
        transition: background 0.3s;
      }
      .toggle-slider::before {
        content: '';
        position: absolute;
        width: 20px;
        height: 20px;
        background: white;
        border-radius: 50%;
        top: 2px;
        left: 2px;
        transition: transform 0.3s;
        box-shadow: 0 2px 4px rgba(0,0,0,0.2);
      }
      .toggle-switch input[type="checkbox"]:checked + .toggle-slider {
        background: var(--primary);
      }
      .toggle-switch input[type="checkbox"]:checked + .toggle-slider::before {
        transform: translateX(26px);
      }
      .toggle-label {
        font-weight: 500;
      }
      
      /* 按钮悬停提示样式 */
      .btn-tooltip {
        position: relative;
        cursor: pointer;
      }
      .btn-tooltip::before {
        content: attr(data-tooltip);
        position: absolute;
        bottom: 100%;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0, 0, 0, 0.9);
        color: white;
        padding: 6px 10px;
        border-radius: 6px;
        font-size: 12px;
        white-space: nowrap;
        z-index: 1000;
        opacity: 0;
        visibility: hidden;
        transition: all 0.2s ease;
        pointer-events: none;
        margin-bottom: 5px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
      }
      .btn-tooltip::after {
        content: '';
        position: absolute;
        bottom: 100%;
        left: 50%;
        transform: translateX(-50%);
        border: 5px solid transparent;
        border-top-color: rgba(0, 0, 0, 0.9);
        opacity: 0;
        visibility: hidden;
        transition: all 0.2s ease;
        pointer-events: none;
        margin-bottom: -1px;
      }
      .btn-tooltip:hover::before,
      .btn-tooltip:hover::after {
        opacity: 1;
        visibility: visible;
        transform: translateX(-50%) translateY(-2px);
      }
      
      /* 紧凑按钮样式 */
      .btn-radio {
        padding: 4px 8px !important;
        font-size: 10px !important;
        border-radius: 4px !important;
      }
      
      
      /* 预测高亮样式 */
      .prediction-highlight {
        background: linear-gradient(120deg, var(--primary) 0%, var(--primary-strong) 100%);
        color: white;
        padding: 2px 6px;
        border-radius: 4px;
        font-weight: 600;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      }
      
      .prediction-level-highlight {
        background: linear-gradient(120deg, var(--warn) 0%, #f59e0b 100%);
        color: white;
        padding: 2px 6px;
        border-radius: 4px;
        font-weight: 600;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      }
      
      .prediction-score-highlight {
        background: linear-gradient(120deg, var(--ok) 0%, #10b981 100%);
        color: white;
        padding: 2px 6px;
        border-radius: 4px;
        font-weight: 600;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      }
      
      /* 全局 Alert 提示（右上角） */
      .alert-stack { position: fixed; top: 16px; right: 16px; display: flex; flex-direction: column; gap: 8px; z-index: 9999; }
      .alert { display:flex; align-items:center; gap:10px; padding:8px 10px; border-radius:6px; font-size:12px; border:1px solid var(--line); box-shadow: 0 2px 6px rgba(0,0,0,0.06); background: var(--card); color: var(--text); }
      .alert-ok { background: rgba(16,185,129,0.08); color:#065f46; border-color: rgba(16,185,129,0.25); }
      .alert-warn { background: rgba(245,158,11,0.10); color:#92400e; border-color: rgba(245,158,11,0.25); }
      .alert-danger { background: rgba(239,68,68,0.10); color:#7f1d1d; border-color: rgba(239,68,68,0.25); }
      .alert .close { background:none; border:none; color:inherit; cursor:pointer; padding:2px 6px; border-radius:4px; }

      /* 预测结果：紧凑行样式 */
      .predict-list { display:flex; flex-direction:column; gap:6px; }
      .predict-row { display:flex; align-items:center; gap:8px; font-size:12px; color:var(--text); flex-wrap: wrap; overflow-wrap:anywhere; word-break:break-word; }
      .predict-badge { padding:2px 6px; border-radius:999px; font-size:11px; line-height:1; }
      .predict-badge.ok { background: rgba(16,185,129,0.12); color:#047857; border:1px solid rgba(16,185,129,0.25); }
      .predict-badge.fail { background: rgba(239,68,68,0.10); color:#991b1b; border:1px solid rgba(239,68,68,0.25); }
      .predict-meta { color: var(--muted); font-size:11px; }
      /* 预测标题中的括号参数更小更淡 */
      .predict-trigs { font-size: 11px; color: var(--muted); font-weight: 500; }
      /* 败北关卡的关卡位警告高亮 */
      .prediction-level-warning { background: var(--warn); color: #4a3c2a; padding: 2px 6px; border-radius: 4px; font-weight: 600; }
      
      /* 紧凑下拉选择框样式 */
      .compact-select {
        padding: 2px 4px !important;
        font-size: 10px !important;
        border-radius: 4px !important;
        min-width: 80px !important;
        height: 24px !important;
        background: #F6F6F4 !important;
        border: 1px solid var(--line) !important;
        color: var(--text) !important;
      }
      
      /* 下拉选择框tooltip支持 */
      .compact-select.btn-tooltip {
        position: relative;
        cursor: pointer;
      }
      
      /* Ant Design风格Tab样式 */
      .antd-tabs-container {
        max-width: 500px;
        margin: 0 auto;
        padding: 0 20px 0 20px;
        background: var(--card);
        border-radius: 8px 8px 0 0;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.06);
      }
      
      .antd-tabs {
        position: relative;
      }
      
      .antd-tab-nav {
        position: relative;
        margin-bottom: 0;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }
      
      .antd-tab-nav-list {
        position: relative;
        display: flex;
        transition: transform 0.3s;
        flex: 1;
      }
      
      .antd-tab-nav-wrap {
        position: relative;
        flex: none;
        min-width: 0;
      }
      
      .antd-tab-nav-extra {
        display: flex;
        align-items: center;
        padding: 0 16px;
      }
      
      .antd-tab-tab {
        position: relative;
        display: inline-flex;
        align-items: center;
        padding: 8px 16px;
        font-size: 14px;
        background: transparent;
        border: 1px solid transparent;
        border-radius: 6px 6px 0 0;
        cursor: pointer;
        transition: all 0.3s;
        margin-right: 2px;
        user-select: none;
      }
      
      .antd-tab-tab:hover {
        color: var(--primary);
      }
      
      .antd-tab-tab-active {
        background: var(--card);
        border-color: var(--line);
        border-bottom-color: var(--card);
        color: var(--primary);
        font-weight: 500;
      }
      
      .antd-tab-tab-active::after {
        content: '';
        position: absolute;
        bottom: -1px;
        left: 0;
        right: 0;
        height: 2px;
        background: var(--primary);
        border-radius: 1px 1px 0 0;
      }
      
      .antd-tab-tab-btn {
        position: relative;
        display: inline-flex;
        align-items: center;
        padding: 4px 0;
        font-size: 12px;
        line-height: 8px;
        color: inherit;
        white-space: nowrap;
        text-align: center;
        background: transparent;
        border: 0;
        outline: none;
        cursor: pointer;
        transition: all 0.3s;
      }
      
      /* 月光控制面板样式 */
      .moonlight-control-panel {
        background: var(--card);
        border: 1px solid var(--line);
        border-radius: var(--radius);
        padding: 20px;
        margin-bottom: 15px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
      }
      
      .moonlight-toggle-section {
        display: flex;
        flex-direction: column;
        gap: 10px;
      }
      
      .toggle-container {
        display: flex;
        align-items: center;
        gap: 15px;
      }
      
      .moonlight-toggle-label {
        font-weight: 600;
        color: var(--primary-strong);
        font-size: 16px;
      }
      
      .moonlight-toggle-switch {
        position: relative;
        display: inline-flex;
        align-items: center;
        gap: 8px;
        cursor: pointer;
      }
      
      .moonlight-toggle-switch input[type="checkbox"] {
        position: absolute;
        opacity: 0;
        width: 0;
        height: 0;
      }
      
      .moonlight-toggle-slider {
        position: relative;
        width: 50px;
        height: 24px;
        background-color: var(--line);
        border-radius: 24px;
        transition: background-color 0.3s ease;
      }
      
      .moonlight-toggle-slider:before {
        content: '';
        position: absolute;
        top: 2px;
        left: 2px;
        width: 20px;
        height: 20px;
        background-color: white;
        border-radius: 50%;
        transition: transform 0.3s ease;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
      }
      
      .moonlight-toggle-switch input:checked + .moonlight-toggle-slider {
        background-color: var(--primary);
      }
      
      .moonlight-toggle-switch input:checked + .moonlight-toggle-slider:before {
        transform: translateX(26px);
      }
      
      .moonlight-toggle-text {
        font-size: 14px;
        color: var(--text);
        font-weight: 500;
      }
      
      .moonlight-description {
        font-size: 13px;
        color: var(--muted);
        line-height: 1.4;
        padding-left: 75px;
      }
      
      /* Tab中的月光开关样式 */
      .tab-moonlight-toggle {
        display: inline-block;
      }
      
      .tab-moonlight-toggle .moonlight-toggle-switch {
        transform: scale(0.7);
      }
      
      .tab-moonlight-toggle .moonlight-toggle-slider {
        width: 36px;
        height: 18px;
      }
      
      .tab-moonlight-toggle .moonlight-toggle-slider:before {
        width: 14px;
        height: 14px;
        top: 2px;
        left: 2px;
      }
      
      .tab-moonlight-toggle .moonlight-toggle-switch input:checked + .moonlight-toggle-slider:before {
        transform: translateX(18px);
      }
      
      .tab-moonlight-toggle .moonlight-toggle-text {
        font-size: 11px;
        margin-left: 6px;
      }
      
      /* 王之召唤开关样式 */
      .king-switch-container {
        position: relative;
        display: inline-block;
        cursor: pointer;
      }
      
      .king-switch-container input[type="checkbox"] {
        position: absolute;
        opacity: 0;
        width: 0;
        height: 0;
      }
      
      .king-switch-slider {
        position: relative;
        display: inline-block;
        width: 44px;
        height: 22px;
        background-color: #d9d9d9;
        border-radius: 11px;
        transition: all 0.3s ease;
        overflow: hidden;
      }
      
      .king-switch-slider:before {
        content: '';
        position: absolute;
        top: 2px;
        left: 2px;
        width: 18px;
        height: 18px;
        background-color: white;
        border-radius: 50%;
        transition: transform 0.3s ease;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        z-index: 2;
      }
      
      .king-switch-container input:checked + .king-switch-slider {
        background-color: #1890ff;
      }
      
      .king-switch-container input:checked + .king-switch-slider:before {
        transform: translateX(22px);
      }
      
      .king-switch-text {
        position: absolute;
        top: 50%;
        transform: translateY(-50%);
        font-size: 10px;
        font-weight: 500;
        color: white;
        transition: opacity 0.3s ease;
        pointer-events: none;
      }
      
      .king-switch-text-on {
        left: 6px;
        opacity: 0;
      }
      
      .king-switch-text-off {
        right: 6px;
        opacity: 1;
      }
      
      .king-switch-container input:checked + .king-switch-slider .king-switch-text-on {
        opacity: 1;
      }
      
      .king-switch-container input:checked + .king-switch-slider .king-switch-text-off {
        opacity: 0;
      }
      
      /* 印章消失计数样式 */
      .seal-counter-container {
        padding: 15px;
      }
      
      .seal-counter-actions {
        display: flex;
        gap: 10px;
        justify-content: center;
      }
      
      .wooden-fish-container {
        display: flex;
        flex-direction: column;
        align-items: center;
        margin: 20px 0;
      }
      
      .fish-and-counter-row {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 30px;
      }
      
      .wooden-fish {
        position: relative;
        cursor: pointer;
        user-select: none;
        transition: transform 0.1s ease;
      }
      
      .wooden-fish:active {
        transform: scale(0.95);
      }
      
      .fish-body {
        font-size: 64px;
        animation: bell-swing 3s ease-in-out infinite;
        transform-origin: top center;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      
      .daoyin-image {
        width: 64px;
        height: 64px;
        object-fit: contain;
        user-select: none;
      }
      
      .fish-shadow {
        position: absolute;
        bottom: -10px;
        left: 50%;
        transform: translateX(-50%);
        width: 40px;
        height: 8px;
        background: rgba(0, 0, 0, 0.2);
        border-radius: 50%;
        animation: shadow-pulse 3s ease-in-out infinite;
      }
      
      .counter-display {
        text-align: center;
      }
      
      .counter-number {
        font-size: 48px;
        font-weight: bold;
        color: var(--primary-strong);
        margin-bottom: 5px;
      }
      
      .counter-label {
        font-size: 14px;
        color: var(--muted);
      }
      
      @keyframes bell-swing {
        0%, 100% { transform: rotate(0deg); }
        25% { transform: rotate(5deg); }
        75% { transform: rotate(-5deg); }
      }
      
      @keyframes shadow-pulse {
        0%, 100% { opacity: 0.2; transform: translateX(-50%) scale(1); }
        50% { opacity: 0.4; transform: translateX(-50%) scale(1.1); }
      }
      
      @keyframes bell-hit {
        0% { transform: rotate(0deg) scale(1); }
        25% { transform: rotate(15deg) scale(1.1); }
        75% { transform: rotate(-15deg) scale(1.1); }
        100% { transform: rotate(0deg) scale(1); }
      }
      
      .wooden-fish.hit {
        animation: bell-hit 0.4s ease;
      }
    </style>
  </head>
  <body>
    <div style="display:flex; justify-content:space-between; align-items:center;">
      <h1>
        <img src="src/assets/fairy16.png" alt="16" style="width: 96px; height: 96px; vertical-align: middle; margin: 0 12px;" />
        青云之志 算分小助手  ——  16祝各位大大欧气满满！
      </h1>
      
      <!-- Tips轮播提示框 -->
      <div class="tips-carousel" style="flex:1; margin:0 20px;">
        <div class="tips-content active" id="tipsContent">进入关卡前和自摸时注意顺序哦</div>
        <div class="tips-dots" id="tipsDots"></div>
      </div>
      
      <div class="result-toggle">
        <label class="toggle-switch">
          <input type="checkbox" id="resultToggle" />
          <span class="toggle-slider"></span>
          <span class="toggle-label">计算结果</span>
        </label>
      </div>
    </div>
    
    <div class="theme-selector">
      <div class="theme-option" data-theme="default">
        <span>莫兰迪</span>
        <div class="theme-colors">
          <div class="theme-color" style="background:#9AA3A0;"></div>
          <div class="theme-color" style="background:#C4B7A6;"></div>
          <div class="theme-color" style="background:#B7D0C5;"></div>
          <div class="theme-color" style="background:#E3C9A8;"></div>
          <div class="theme-color" style="background:#D9B8B6;"></div>
        </div>
      </div>
      <div class="theme-option active" data-theme="16QwQ">
        <span>16QwQ</span>
        <div class="theme-colors">
          <div class="theme-color" style="background:#73CCFF;"></div>
          <div class="theme-color" style="background:#ACF06D;"></div>
          <div class="theme-color" style="background:#F0DF6D;"></div>
          <div class="theme-color" style="background:#E8A469;"></div>
          <div class="theme-color" style="background:#AC9076;"></div>
        </div>
      </div>
      <div class="theme-option" data-theme="buxingshx">
        <span>布识星河</span>
        <div class="theme-colors">
          <div class="theme-color" style="background:#00E874;"></div>
          <div class="theme-color" style="background:#EEFF00;"></div>
          <div class="theme-color" style="background:#00B0F0;"></div>
          <div class="theme-color" style="background:#FFFFFF; border:1px solid #ccc;"></div>
          <div class="theme-color" style="background:#B6FF47;"></div>
        </div>
      </div>
      <div class="theme-option" data-theme="life">
        <span>生命序章</span>
        <div class="theme-colors">
          <div class="theme-color" style="background:#A5EAFF;"></div>
          <div class="theme-color" style="background:#BEFFF8;"></div>
          <div class="theme-color" style="background:#9EC4F6;"></div>
          <div class="theme-color" style="background:#E1DCFC;"></div>
          <div class="theme-color" style="background:#D2C0F9;"></div>
        </div>
      </div>
      <div class="theme-option" data-theme="purple">
        <span>紫鼠法翠</span>
        <div class="theme-colors">
          <div class="theme-color" style="background:#FFF200;"></div>
          <div class="theme-color" style="background:#65BFBE;"></div>
          <div class="theme-color" style="background:#BDE031;"></div>
          <div class="theme-color" style="background:#DEEDA1;"></div>
          <div class="theme-color" style="background:#008F75;"></div>
        </div>
      </div>
      <div class="theme-option" data-theme="rainbow">
        <span>彩虹小小</span>
        <div class="theme-colors">
          <div class="theme-color" style="background:#FFB78C;"></div>
          <div class="theme-color" style="background:#FFF08C;"></div>
          <div class="theme-color" style="background:#BBFF8C;"></div>
          <div class="theme-color" style="background:#8CFFCE;"></div>
          <div class="theme-color" style="background:#BD8CFF;"></div>
        </div>
      </div>
      <div class="theme-option" data-theme="wonderful">
        <span>不思议世界</span>
        <div class="theme-colors">
          <div class="theme-color" style="background:#191A1E;"></div>
          <div class="theme-color" style="background:#482E31;"></div>
          <div class="theme-color" style="background:#FF3B3E;"></div>
          <div class="theme-color" style="background:#FF8657;"></div>
          <div class="theme-color" style="background:#FFBA70;"></div>
        </div>
      </div>
      <div class="theme-option" data-theme="16yyds">
        <span>十六YYDS</span>
        <div class="theme-colors">
          <div class="theme-color" style="background:#E5FD56;"></div>
          <div class="theme-color" style="background:#C6DC74;"></div>
          <div class="theme-color" style="background:#A8BB92;"></div>
          <div class="theme-color" style="background:#899AB0;"></div>
          <div class="theme-color" style="background:#6A79CE;"></div>
        </div>
      </div>
      <div class="theme-option" data-theme="easter-egg">
        <span>讨厌十六</span>
        <div class="theme-colors">
          <div class="theme-color" style="background:#FF0000;"></div>
          <div class="theme-color" style="background:#FF6600;"></div>
          <div class="theme-color" style="background:#FFCC00;"></div>
          <div class="theme-color" style="background:#00FF00;"></div>
          <div class="theme-color" style="background:#0066FF;"></div>
        </div>
      </div>
    </div>
    
    <!-- 彩蛋模态框 -->
    <div id="easterEggModal" class="modal">
      <div class="modal-content">
        <h2>🎉 彩蛋！</h2>
        <p>你敢点这个，达鼠泥，给16打钱！<br>hahahahaha 😄</p>
        <div style="text-align: center; margin: 20px 0;">
          <div style="display: flex; justify-content: center; align-items: center; gap: 20px; margin-bottom: 15px;">
            <img src="src/assets/yiyi.jpg" alt="notGood" style="max-width: 45%; height: auto;" />
            <img src="src/assets/appreciate.jpg" alt="appreciate" style="max-width: 45%; height: auto;" />
          </div>
          <div style="margin: 10px 0;">蟹蟹泥~</div>
        </div>
        <button onclick="closeEasterEgg()">关闭</button>
      </div>
    </div>
    

    <!-- Tab导航 - Ant Design风格 -->
    <div class="antd-tabs-container">
      <div class="antd-tabs">
        <div class="antd-tab-nav">
          <div class="antd-tab-nav-list">
            <div class="antd-tab-nav-wrap">
              <div class="antd-tab-tab" data-tab="index">
                <div class="antd-tab-tab-btn">指数三大件</div>
              </div>
              <div class="antd-tab-tab antd-tab-tab-active" data-tab="hacker">
                <div class="antd-tab-tab-btn">黑客流派</div>
              </div>
            </div>
          </div>
          <!-- 右侧开关区域 -->
          <div class="antd-tab-nav-extra">
            <div class="tab-moonlight-toggle" id="tabFuzhongToggle" style="display: none;">
              <label class="moonlight-toggle-switch">
                <input type="checkbox" id="fuzhongToggle" checked />
                <span class="moonlight-toggle-slider"></span>
                <span class="moonlight-toggle-text" id="fuzhongToggleText">负重</span>
              </label>
            </div>
            <div class="tab-moonlight-toggle" id="tabMoonlightToggle" style="display: none;">
              <label class="moonlight-toggle-switch">
                <input type="checkbox" id="moonlightToggle" checked />
                <span class="moonlight-toggle-slider"></span>
                <span class="moonlight-toggle-text" id="moonlightToggleText">月光</span>
              </label>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="row" id="main-content" style="margin-top: 0; border-top: 1px solid var(--line);">
      <div class="col-left">
        <div class="card">
        <div class="card-header">
          <div style="display:flex; align-items:center; justify-content:space-between; width:100%;">
            <h3>关卡配置与护身符设置</h3>
            <div class="block-selector" style="display:flex; gap:4px; margin:0; flex-wrap:wrap;">
              <button class="block-btn active" data-block="level-select">选择关卡</button>
              <button class="block-btn active" data-block="values">数值设置</button>
              <button class="block-btn active" data-block="triggers">触发次数与王之召唤</button>
              <button class="block-btn " data-block="display">大数字单位</button>
              <button class="block-btn " data-block="tech">科技</button>
              <button class="block-btn " data-block="shop">商店刷新星币</button>
              <button class="block-btn active" data-block="seal-counter">印章消失计数</button>
              <button class="block-btn active" data-block="predict">未来关卡预测</button>
            </div>
            <div style="margin-top: 8px; font-size: 12px; color: var(--muted); text-align: center; display: flex; align-items: center; justify-content: center; gap: 8px;">
              <span>万、亿、兆、京、垓、秭、穰、沟、涧、正、载、极</span>
              <img id="lolipopIcon" src="src/assets/lolipop16.png" alt="lolipop" style="width: 64px; height: 64px; opacity: 0.7; cursor: pointer;" />
            </div>
            <button class="card-toggle" data-target="config-content">−</button>
          </div>
        </div>
        <div class="card-content" id="config-content">
        
        <!-- 两列布局：左侧选择关卡(15%)，右侧其他区块(85%) -->
        <div style="display: flex; gap: 12px; margin-bottom: 16px;">
          
          <!-- 左侧：选择关卡 -->
          <div class="config-block" data-block="level-select" style="flex: 0 0 15%; min-width: 180px;">
            <div class="resize-handle left" data-resize="left"></div>
            <div class="resize-handle right" data-resize="right"></div>
            <div style="display:flex; justify-content:space-between; align-items:center;">
              <h4 style="margin:0;">选择关卡</h4>
              <div style="display:flex; gap:4px;">
                <button id="prevLevel" style="padding:4px 8px; font-size:12px;" title="上一关">◀</button>
                <button id="nextLevel" style="padding:4px 8px; font-size:12px;" title="下一关">▶</button>
              </div>
            </div>
            <div class="block-content expanded">
            <label>目标分数
              <input id="targetScore" value="200" />
            </label>
            <label>选择关卡
              <select id="levelSelect"></select>
            </label>
            
            <!-- 起始关卡设置 -->
            <div style="margin-top: 12px; padding-top: 12px; border-top: 1px solid var(--line);">
              <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;">
                <span style="font-weight:600; color:var(--text);">起始关卡</span>
                <button id="unlockApply" style="padding:4px 8px; font-size:12px;">确认</button>
              </div>
              <label>盗印
                <select id="unlockD"></select>
              </label>
              <label>负重
                <select id="unlockF"></select>
              </label>
              <label>月光
                <select id="unlockY"></select>
              </label>
            </div>
            </div>
          </div>
          <!-- 右侧：其他区块flex布局 -->
          <div class="blocks-grid" id="blocksGrid" style="display: flex; flex-wrap: wrap; gap: 8px; flex: 1; width: 100%;">
          <!-- 区块2：数值设置 -->
          <div class="config-block" data-block="values" style="flex: 1; min-width: 200px;">
            <div class="resize-handle left" data-resize="left"></div>
            <div class="resize-handle right" data-resize="right"></div>
            <h4>数值设置<span class="block-toggle">▼</span></h4>
            <div class="block-content expanded">
            <label>胡牌番数
              <input id="finalMulInput" value="30" />
            </label>
            <label>小分分值
              <input id="baseScore" value="77" />
            </label>
            <label>盗印番数
              <input id="daoyin" value="2" readonly />
            </label>
            <div id="daoyin_display" style="font-size:10px; color:#9ca3af; margin:2px 0 8px 0; min-height:12px; text-align:right; padding-right:4px;"></div>
            <label>负重番数
              <input id="fuzhong" value="1.5" readonly />
            </label>
            <div id="fuzhong_display" style="font-size:10px; color:#9ca3af; margin:2px 0 8px 0; min-height:12px; text-align:right; padding-right:4px;"></div>
            <label>月光番数
              <input id="yueguang" value="2.5" readonly />
            </label>
            <div id="yueguang_display" style="font-size:10px; color:#9ca3af; margin:2px 0 8px 0; min-height:12px; text-align:right; padding-right:4px;"></div>
            </div>
          </div>
          <!-- 区块4：触发次数与王之召唤 -->
          <div class="config-block" data-block="triggers" style="flex: 1; min-width: 200px;">
            <div class="resize-handle left" data-resize="left"></div>
            <div class="resize-handle right" data-resize="right"></div>
            <h4>触发次数与王之召唤<span class="block-toggle">▼</span></h4>
            <div class="block-content expanded">
            
            <!-- 触发次数和理论最大次数在同一行 -->
            <div style="display:flex; gap:16px; margin-bottom:12px;">
              <!-- 实际触发次数 -->
              <div style="flex:1;">
                <div style="font-size:12px;color:#374151;margin-bottom:8px;">实际触发次数</div>
                <div style="display:flex; flex-direction:column; gap:6px;">
                  <div style="display:flex; align-items:center; gap:8px;">
                    <label style="font-size:11px;color:#6b7280; min-width:40px;">盗印:</label>
                    <input id="trigD" type="number" value="4" min="0" step="1" style="padding:4px; flex:1;" />
                  </div>
                  <div style="display:flex; align-items:center; gap:8px;">
                    <label style="font-size:11px;color:#6b7280; min-width:40px;">负重:</label>
                    <input id="trigF" type="number" value="7" min="0" step="1" style="padding:4px; flex:1;" />
                  </div>
                  <div style="display:flex; align-items:center; gap:8px;">
                    <label style="font-size:11px;color:#6b7280; min-width:40px;">月光:</label>
                    <input id="trigY" type="number" value="5" min="0" step="1" style="padding:4px; flex:1;" />
                  </div>
                </div>
              </div>
              
              <!-- 理论最大次数 -->
              <div style="flex:1;">
                <div style="font-size:12px;color:#374151;margin-bottom:8px;">理论最大次数</div>
                <div style="display:flex; flex-direction:column; gap:6px;">
                  <div style="display:flex; align-items:center; gap:8px;">
                    <label style="font-size:11px;color:#6b7280; min-width:40px;">盗印:</label>
                    <input id="theoD" type="number" value="6" min="0" step="1" style="padding:4px; flex:1;" />
                  </div>
                  <div style="display:flex; align-items:center; gap:8px;">
                    <label style="font-size:11px;color:#6b7280; min-width:40px;">负重:</label>
                    <input id="theoF" type="number" value="7" min="0" step="1" style="padding:4px; flex:1;" />
                  </div>
                  <div style="display:flex; align-items:center; gap:8px;">
                    <label style="font-size:11px;color:#6b7280; min-width:40px;">月光:</label>
                    <input id="theoY" type="number" value="5" min="0" step="1" style="padding:4px; flex:1;" />
                  </div>
                </div>
              </div>
            </div>
            
            <!-- 王之召唤 -->
            <div style="margin-top:12px; padding-top:12px; border-top:1px solid var(--line);">
              <div style="display:flex; align-items:center; gap:8px; margin-bottom:8px;">
                <label class="king-switch-container">
                  <input type="checkbox" id="kingEnabled" />
                  <span class="king-switch-slider">
                    <span class="king-switch-text king-switch-text-on">开启</span>
                    <span class="king-switch-text king-switch-text-off">关闭</span>
                  </span>
                </label>
                <span style="font-size:12px;color:#374151;">王之召唤</span>
              </div>
              <div id="kingBox" style="display:none;">
                <div style="font-size:12px;color:#374151;margin-bottom:8px;">王之召唤触发次数</div>
                <div style="display:flex; gap:8px; margin-bottom:8px;">
                  <div style="display:flex; align-items:center; gap:8px;">
                    <label style="font-size:11px;color:#6b7280; min-width:40px;">实际:</label>
                    <input id="trigK" type="number" value="4" min="0" step="1" style="padding:4px; flex:1;" />
              </div>
                  <div style="display:flex; align-items:center; gap:8px;">
                    <label style="font-size:11px;color:#6b7280; min-width:40px;">理论:</label>
                    <input id="maxTrigK" type="number" value="4" min="0" step="1" style="padding:4px; flex:1;" />
                  </div>
                </div>
                <div style="font-size:11px;color:#6b7280; margin-bottom:8px;">王之召唤 以14张全魂牌为基础计算<br>若有筒索失效debuff请自行修改下一关番数:P</div>
              </div>
            </div>
            </div>
          </div>
          <!-- 区块5：大数字单位 -->
          <div class="config-block" data-block="display" style="flex: 1; min-width: 200px;">
            <div class="resize-handle left" data-resize="left"></div>
            <div class="resize-handle right" data-resize="right"></div>
            <h4>大数字单位系统对照表<span class="block-toggle">▼</span></h4>
            <div class="block-content expanded">
            <div class="data-table">
              <table>
                <thead>
                  <tr>
                    <th>单位</th>
                    <th>指数</th>
                  </tr>
                </thead>
                <tbody>
                  <tr><td>万</td><td>10^4</td></tr>
                  <tr><td>亿</td><td>10^8</td></tr>
                  <tr><td>兆</td><td>10^12</td></tr>
                  <tr><td>京</td><td>10^16</td></tr>
                  <tr><td>垓</td><td>10^20</td></tr>
                  <tr><td>秭</td><td>10^24</td></tr>
                  <tr><td>穰</td><td>10^28</td></tr>
                  <tr><td>沟</td><td>10^32</td></tr>
                  <tr><td>涧</td><td>10^36</td></tr>
                  <tr><td>正</td><td>10^40</td></tr>
                  <tr><td>载</td><td>10^44</td></tr>
                  <tr><td>极</td><td>10^48</td></tr>
                </tbody>
              </table>
            </div>
            </div>
          </div>
          <!-- 区块678合并：魂牌/公开牌/宝牌指示牌 -->
          <div class="config-block" data-block="tech" style="flex: 1; min-width: 300px;">
            <div class="resize-handle left" data-resize="left"></div>
            <div class="resize-handle right" data-resize="right"></div>
            <h4>魂牌 - 公开牌 - 宝牌指示牌<span class="block-toggle">▼</span></h4>
            <div class="block-content expanded">
            <div class="data-table">
              <table>
                <thead>
                  <tr>
                    <th>次数</th>
                    <th>星币</th>
                    <th>次数</th>
                    <th>星币</th>
                    <th>次数</th>
                    <th>星币</th>
                  </tr>
                </thead>
                <tbody>
                  <tr><td class="count-cell">0/9</td><td>10</td><td class="count-cell">6/18</td><td>2</td><td class="count-cell">1/10</td><td>5</td></tr>
                  <tr><td class="count-cell">1/9</td><td>20</td><td class="count-cell">7/18</td><td>4</td><td class="count-cell">2/10</td><td>10</td></tr>
                  <tr><td class="count-cell">2/9</td><td>30</td><td class="count-cell">8/18</td><td>6</td><td class="count-cell">3/10</td><td>15</td></tr>
                  <tr><td class="count-cell">3/9</td><td>40</td><td class="count-cell">9/18</td><td>8</td><td class="count-cell">4/10</td><td>20</td></tr>
                  <tr><td class="count-cell">4/9</td><td>50</td><td class="count-cell">10/18</td><td>10</td><td class="count-cell">5/10</td><td>30</td></tr>
                  <tr><td class="count-cell">5/9</td><td>80</td><td class="count-cell">11/18</td><td>20</td><td class="count-cell">6/10</td><td>50</td></tr>
                  <tr><td class="count-cell">6/9</td><td>100</td><td class="count-cell">12/18</td><td>30</td><td class="count-cell">7/10</td><td>80</td></tr>
                  <tr><td class="count-cell">7/9</td><td>150</td><td class="count-cell">13/18</td><td>40</td><td class="count-cell">8/10</td><td>120</td></tr>
                  <tr><td class="count-cell">8/9</td><td>200</td><td class="count-cell">14/18</td><td>50</td><td class="count-cell">9/10</td><td>160</td></tr>
                  <tr><td class="count-cell"> </td><td> </td><td class="count-cell">15/18</td><td>80</td><td class="count-cell"> </td><td> </td></tr>
                  <tr><td class="count-cell"> </td><td> </td><td class="count-cell">16/18</td><td>120</td><td class="count-cell"> </td><td> </td></tr>
                  <tr><td class="count-cell"> </td><td> </td><td class="count-cell">17/18</td><td>160</td><td class="count-cell"> </td><td> </td></tr>
                </tbody>
              </table>
            </div>
            </div>
          </div>
          
          <!-- 区块8：商店刷新星币 -->
          <div class="config-block" data-block="shop" style="flex: 1; min-width: 200px;">
            <div class="resize-handle left" data-resize="left"></div>
            <div class="resize-handle right" data-resize="right"></div>
            <h4>商店刷新星币<span class="block-toggle">▼</span></h4>
            <div class="block-content expanded">
          <div class="data-table">
            <table>
              <thead>
                <tr>
                  <th>刷新次数</th>
                  <th>所需星币</th>
                </tr>
              </thead>
              <tbody>
                <tr><td>1</td><td>2</td></tr>
                <tr><td>2</td><td>3</td></tr>
                <tr><td>3</td><td>5</td></tr>
                <tr><td>4</td><td>8</td></tr>
                <tr><td>5</td><td>12</td></tr>
                <tr><td>6</td><td>18</td></tr>
                <tr><td>7</td><td>27</td></tr>
                <tr><td>8</td><td>41</td></tr>
                <tr><td>9</td><td>93</td></tr>
                <tr><td>10</td><td>140</td></tr>
                <tr><td>11</td><td>210</td></tr>
                <tr><td>12</td><td>315</td></tr>
                <tr><td>13</td><td>473</td></tr>
                <tr><td>14</td><td>710</td></tr>
                <tr><td>15</td><td>1065</td></tr>
                <tr><td>16</td><td>1598</td></tr>
                <tr><td>17</td><td>2397</td></tr>
                <tr><td>18</td><td>3596</td></tr>
                <tr><td>19</td><td>5394</td></tr>
                <tr><td>20</td><td>8091</td></tr>
                <tr><td>21</td><td>12137</td></tr>
                <tr><td>22</td><td>18206</td></tr>
              </tbody>
            </table>
          </div>
            </div>
          </div>
          
          <!-- 区块：印章消失计数 -->
          <div class="config-block" data-block="seal-counter" style="flex: 1; min-width: 300px;">
            <div class="resize-handle left" data-resize="left"></div>
            <div class="resize-handle right" data-resize="right"></div>
            <h4>印章消失计数<span class="block-toggle">▼</span></h4>
            <div class="block-content expanded">
              <div class="seal-counter-container">
                <label>你想从哪一关的盗印开始加呢？
                  <select id="sealCounterLevel" class="compact-select">
                    <option value="">请选择关卡...</option>
                  </select>
                </label>
                
                <div class="seal-counter-actions" style="margin-top: 15px;">
                  <button id="confirmSealLevel" class="btn" disabled style="background-color: #ccc; color: #666; cursor: not-allowed;">确认关卡</button>
                  <button id="resetSealCounter" class="btn btn-secondary">清零</button>
                </div>
                
                <div class="seal-counter-display" id="sealCounterDisplay" style="display: none; margin-top: 20px; text-align: center;">
                  <div class="current-level-info" style="margin-bottom: 15px; padding: 10px; background: var(--accent-light); border-radius: 8px;">
                    <div style="font-size: 12px; color: var(--muted);">印章类型: <span id="currentGrowthType">-</span></div>
                  </div>
                  
                  <div class="wooden-fish-container">
                    <div class="fish-and-counter-row">
                      <div class="wooden-fish" id="woodenFish">
                        <div class="fish-body">
                          <img src="src/assets/daoyin.png" alt="盗印" class="daoyin-image" />
                        </div>
                        <div class="fish-shadow"></div>
                      </div>
                      <div class="counter-display">
                        <div class="counter-number" id="sealCounterNumber">0</div>
                        <div class="counter-label">敲击次数</div>
                      </div>
                    </div>
                  </div>
                  
                  <div class="seal-value-display" style="margin-top: 15px; padding: 10px; background: var(--card); border: 1px solid var(--line); border-radius: 8px;">
                    <div style="font-weight: 600; margin-bottom: 5px;">关卡: <span id="currentSealLevel">-</span> 盗印番数变化:</div>
                    <div id="sealValueChange" style="font-size: 14px; color: var(--primary-strong);">0 → 0</div>
                  </div>
                </div>
              </div>
            </div>
          </div>
          
          <!-- 区块9：未来关卡预测区块 -->
          <div class="config-block" data-block="predict" style="flex: 1; min-width: 300px;">
            <div class="resize-handle left" data-resize="left"></div>
            <div class="resize-handle right" data-resize="right"></div>
            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;">
              <span style="font-weight:600; color:var(--text);">未来关卡预测</span>
              <button id="updatePrediction">更新预测</button>
            </div>
            <div class="card-content" id="prediction-content">
              <!-- 当前关卡信息与得分对比 -->
              <div id="currentLevelInfo" style="display:none; margin-bottom:16px; padding:12px; background:var(--accent); border-radius:8px;">
                <!-- 第一行：当前关卡+目标分，实际得分，理论得分 -->
                <div style="display:flex; gap:16px; margin-bottom:12px;">
                  <div style="flex:1; min-width:250px;">
                    <div style="font-size:12px; color:var(--muted); margin-bottom:4px;">当前关卡与目标分</div>
                    <div id="predCurrentLevelTarget" style="font-size:13px; color:var(--text);">请先进行计算</div>
                  </div>
                  <div style="flex:1; min-width:200px;">
                    <div style="font-size:12px; color:var(--muted); margin-bottom:4px;">实际当前总得分</div>
                    <div id="predCurrentScore" style="font-size:13px; color:var(--text);">-</div>
                  </div>
                  <div style="flex:1; min-width:200px;">
                    <div style="font-size:12px; color:var(--muted); margin-bottom:4px;">理论最高当前关总得分</div>
                    <div id="predMaxScore" style="font-size:13px; color:var(--text);">-</div>
                  </div>
                </div>
                
                <!-- 第二行：分解（番数与触发次数） -->
                <div style="padding-top:12px; border-top:1px solid var(--line);">
                  <div style="font-size:12px; color:var(--muted); margin-bottom:8px;">分解（番数与触发次数）</div>
                  <div id="predBreakdown" style="font-size:13px; line-height:1.6; color:var(--text); display:flex; gap:16px;">-</div>
                </div>
              </div>
              
              <!-- 预测结果 -->
              <div style="display:flex; gap:16px; flex-wrap:wrap; align-items:stretch;">
                <!-- 当前触发次数预测 -->
                <div style="border:1px solid var(--line); border-radius:8px; padding:12px; flex:1; min-width:260px; display:flex; flex-direction:column;">
                  <h5 style="margin:0 0 12px 0; color:var(--text); font-size:14px; display:flex; align-items:center; gap:8px;">
                    <span>实际预测<span class="predict-trigs">（盗印=<span id="currentDaoyinTriggers">-</span>, 负重=<span id="currentFuzhongTriggers">-</span>, 月光=<span id="currentYueguangTriggers">-</span>）</span></span>
                    <span style="margin-left:auto; display:flex; gap:6px; align-items:center;" id="currentPredQuickStatus"></span>
                  </h5>
                  <div id="currentPrediction" style="font-size:11px; line-height:1.6; color:var(--text); margin-top:auto;">请先进行计算</div>
                </div>
                
                <!-- 理论最大触发次数预测 -->
                <div style="border:1px solid var(--line); border-radius:8px; padding:12px; flex:1; min-width:260px; display:flex; flex-direction:column;">
                  <h5 style="margin:0 0 12px 0; color:var(--text); font-size:14px; display:flex; align-items:center; gap:8px;">
                    <span>理论预测<span class="predict-trigs">（盗印=<span id="maxDaoyinTriggers">-</span>, 负重=<span id="maxFuzhongTriggers">-</span>, 月光=<span id="maxYueguangTriggers">-</span>）</span></span>
                    <span style="margin-left:auto; display:flex; gap:6px; align-items:center;" id="maxPredQuickStatus"></span>
                  </h5>
                  <div id="maxPrediction" style="font-size:11px; line-height:1.6; color:var(--text); margin-top:auto;">请先进行计算</div>
                </div>
              </div>
            </div>
          </div>
        </div>
          
          </div> <!-- 关闭右侧区块网格 -->
        </div> <!-- 关闭两列布局 -->
        
        </div>
      </div>

      

      <!-- 悬浮结果窗 -->
      <div id="floatingResult" class="floating-window" style="display:none;">
        <div class="floating-header">
          <div class="floating-title">计算结果</div>
          <div class="floating-controls">
            <button class="floating-close" id="floatingClose">×</button>
          </div>
        </div>
        <div class="floating-content" id="floatingContent">
          <div style="display:flex; align-items:center; justify-content:space-between; margin-bottom:10px;">
            <div style="display:flex; align-items:center; gap:8px;">
              <span style="font-size:12px; color:#374151;">精度:</span>
              <div class="precision-buttons">
                <button class="precision-btn active" data-precision="2">2位</button>
                <button class="precision-btn" data-precision="4">4位</button>
              </div>
            </div>
            <div style="display:flex; align-items:center; gap:10px;">
              <button id="btn">计算</button>
              <span id="status" class="status">未计算</span>
            </div>
          </div>
          <div class="grid-3">
            <div>
              <div style="font-size:12px;color:#374151;">实际当前总得分</div>
              <div id="resTotalSci" style="font-weight:600;">-</div>
              <div id="resTotalCn" style="color:#6b7280;">-</div>
            </div>
            <div>
              <div style="font-size:12px;color:#374151;">理论最高当前关总得分</div>
              <div id="resTheoSci" style="font-weight:600;">-</div>
              <div id="resTheoCn" style="color:#6b7280;">-</div>
            </div>
            <div>
              <div style="font-size:12px;color:#374151;">目标分（用于对比）</div>
              <div id="resTargetSci" style="font-weight:600;">-</div>
              <div id="resTargetCn" style="color:#6b7280;">-</div>
            </div>
          </div>
          <div style="margin-top:8px; font-size:12px; color:#374151;">分解（番数与触发次数）</div>
          <div class="grid-3" style="margin-top:6px;">
            <div>
              <strong>盗印</strong>
              <div id="bdD">-</div>
            </div>
            <div>
              <strong>负重</strong>
              <div id="bdF">-</div>
            </div>
            <div>
              <strong>月光</strong>
              <div id="bdY">-</div>
            </div>
          </div>
          
          <!-- 王之召唤调试信息显示区域 -->
          <!--
          <div id="kingSummonDebug" style="display:none; margin-top:12px; padding:8px; background:#f8f9fa; border:1px solid #dee2e6; border-radius:4px; font-size:11px;">
            <div style="font-weight:bold; margin-bottom:4px; color:#495057;">🎯 王之召唤计算详情</div>
            <div id="kingDebugContent" style="color:#6c757d; line-height:1.4;"></div>
          </div>
          -->
          
          <!-- 详细计算步骤调试信息显示区域 -->
          <!--
          <div id="detailedCalculationDebug" style="display:none; margin-top:12px; padding:8px; background:#fff3cd; border:1px solid #ffeaa7; border-radius:4px; font-size:11px;">
            <div style="font-weight:bold; margin-bottom:4px; color:#856404;">🔍 详细计算步骤</div>
            <div id="detailedDebugContent" style="color:#856404; line-height:1.4;"></div>
          </div>
          -->
        </div>
      </div>

    <div class="card" style="margin-top:var(--gap); width:100%; max-width:100%;">
      <div class="card-header" style="display:flex; justify-content:space-between; align-items:center;">
        <div>
          <h3>关卡目标分（分页展示，每页6项）</h3>
        </div>
        <div style="display:flex; gap:16px; align-items:center;">
          <div style="display:flex; gap:6px; align-items:center; flex-wrap:nowrap; white-space:nowrap;">
            <select id="historySelect" style="font-size:12px; padding:4px 8px; border:1px solid var(--line); border-radius:6px; background:var(--card); color:var(--text); min-width:180px;">
              <option value="">选择历史配置</option>
            </select>
            <button id="dropdownDeleteBtn" class="btn-radio btn-light" style="font-size:12px; padding:4px 8px; white-space:nowrap;">删除当前配置…</button>
          </div>

          <div style="display:flex; gap:6px; align-items:center;">
            <button id="saveCurrentBtn" class="btn-radio" style="font-size:12px; padding:4px 8px;">存储当前数据</button>
            <div id="saveFlow" style="display:none; gap:6px; align-items:center;">
              <input id="historyName" placeholder="输入名称" style="font-size:12px; padding:4px 8px; width:160px; border:1px solid var(--line); border-radius:6px; background:var(--card); color:var(--text);" />
              <button id="confirmSaveBtn" class="btn-radio" style="font-size:12px; padding:4px 8px;">确认</button>
              <button id="cancelSaveBtn" class="btn-radio btn-light" style="font-size:12px; padding:4px 8px;">取消</button>
            </div>
          </div>

          <div style="display:flex; gap:4px; align-items:center; margin-left:auto;">
            <span style="font-size:12px; color:#374151;">布局:</span>
            <button id="layoutSwitch" class="btn-radio active" data-layout="single" style="font-size:12px; padding:4px 8px;">单行</button>
            <button id="layoutSwitch2" class="btn-radio" data-layout="two-column" style="font-size:12px; padding:4px 8px;">两栏</button>
          </div>
          <button id="prev5">上一页</button>
          <div style="display:flex; align-items:center; gap:4px;">
            <span style="font-size:12px; color:#374151;">第</span>
            <input type="number" id="pageInput5" min="1" max="1" style="width:50px; padding:2px 4px; text-align:center; font-size:12px;" oninput="this.value = Math.max(this.min, Math.min(this.max, this.value))" />
            <span style="font-size:12px; color:#374151;">页</span>
            <button id="goToPage5" style="font-size:12px; padding:2px 6px;">跳转</button>
          </div>
          <button id="next5">下一页</button>
          <span id="pageInfo5"></span>
          <button class="card-toggle" data-target="level5-content">−</button>
        </div>
      </div>
      <div class="card-content" id="level5-content">
        <div id="levelList5"></div>
      </div>
    </div>


    
    <script>
      // 自动端口/环境检测
      // 生产环境（如 Azure）使用同源相对路径；本地开发保持端口扫描
      let API_BASE = '';
      let api = '/api/calc';
      
      // 检测后端端口
      async function detectBackendPort() {
        const ports = [6001, 6002, 6003, 6004, 6005, 6006, 6007, 6008, 6009, 6010];
        
        console.log('🔍 Starting backend port detection...');
        
        for (const port of ports) {
          try {
            console.log(`🔍 Checking port ${port}...`);
            
            // 创建超时控制器
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 1000);
            
            const response = await fetch(`http://127.0.0.1:${port}/api/health`, {
              method: 'GET',
              mode: 'cors',
              cache: 'no-store',
              signal: controller.signal
            });
            
            clearTimeout(timeoutId);
            
            if (response.ok) {
              const data = await response.json();
              if (data.status === 'ok') {
                console.log(`🎯 Backend detected on port ${port}`);
                return port;
              }
            }
          } catch (error) {
            // 端口不可用，继续尝试下一个
            console.log(`❌ Port ${port} not available: ${error.message}`);
            continue;
          }
        }
        
        throw new Error('Backend server not found on any port');
      }
      
      // 初始化API配置
      async function initAPI() {
        try {
          // 判断是否为本地环境：hostname 为 localhost/127.0.0.1
          const isLocal = ['localhost', '127.0.0.1'].includes(location.hostname);
          if (isLocal) {
            const port = await detectBackendPort();
            API_BASE = `http://127.0.0.1:${port}`;
            api = `${API_BASE}/api/calc`;
            console.log(`✅ API configured: ${API_BASE}`);
            showPortStatus(port);
          } else {
            // 生产环境直接使用同源相对路径，避免 CORS/端口问题
            API_BASE = '';
            api = '/api/calc';
            console.log(`✅ API configured (production same-origin): ${location.origin}`);
          }
        } catch (error) {
          console.error('❌ Failed to detect backend:', error.message);
          console.log('🔄 Using default port 6001');
          showPortStatus(6001, true);
        }
      }
      
      // 显示端口状态
      function showPortStatus(port, isDefault = false) {
        // 创建或更新端口状态显示
        let statusEl = document.getElementById('port-status');
        if (!statusEl) {
          statusEl = document.createElement('div');
          statusEl.id = 'port-status';
          statusEl.style.cssText = `
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
            font-family: monospace;
            z-index: 10000;
            pointer-events: none;
            transition: opacity 0.3s;
          `;
          document.body.appendChild(statusEl);
        }
        
        statusEl.innerHTML = `
          <div style="display: flex; align-items: center; gap: 6px;">
            <span style="color: ${isDefault ? '#ff6b6b' : '#51cf66'};">
              ${isDefault ? '⚠️' : '✅'}
            </span>
            <span>Backend: ${port}</span>
          </div>
        `;
        
        // 3秒后完全消失
        setTimeout(() => {
          if (statusEl) {
            statusEl.style.opacity = '0';
            // 等待过渡动画完成后移除元素
            setTimeout(() => {
              if (statusEl && statusEl.parentNode) {
                statusEl.parentNode.removeChild(statusEl);
              }
            }, 300); // 等待0.3s的过渡动画完成
          }
        }, 3000);
      }
      
      // 页面加载时自动检测端口
      initAPI();
      // 前端同样提供大数解析与格式化，用于输入/回显
      const CN_UNITS = ["万","亿","兆","京","垓","秭","穰","沟","涧","正","载","极"]; const CN_EXPS = [4,8,12,16,20,24,28,32,36,40,44,48];
      function parseChinaJiLocal(raw) {
        const s = String(raw||'').trim();
        if (!s) return null;
        if (/^[-+]?\d+(?:\.\d+)?(?:e[-+]?\d+)?$/i.test(s)) return s;
        
        // 修复：支持"20000万.3434"这种格式，正确处理小数部分
        // 先尝试匹配：数字 + 单位 + .小数 格式
        let m = s.match(/^\s*([-+]?\d+)\s*([万亿兆京垓秭穰沟涧正载])\s*(\.\d+)\s*(极*)\s*$/);
        if (m) {
          const integerPart = parseFloat(m[1]);
          const unit = m[2];
          const decimalPart = m[3];
          const j = (m[4]||'').length;
          
          const idx = CN_UNITS.indexOf(unit);
          if (idx >= 0) {
            const base = CN_EXPS[idx];
            const result = (integerPart + parseFloat(decimalPart)) * Math.pow(10, base + j*48);
            return result.toString();
          }
        }
        
        // 匹配格式：数字(可选小数) + 单位(可选) + 极(可选)
        m = s.match(/^\s*([-+]?\d+(?:\.\d+)?)\s*([万亿兆京垓秭穰沟涧正载]?)(极*)\s*$/);
        if (!m) return null;
        
        const coeff = parseFloat(m[1]); 
        const unit = m[2]||''; 
        const j = (m[3]||'').length;
        
        let base = 0; 
        if (unit) { 
          const idx = CN_UNITS.indexOf(unit); 
          if (idx >= 0) base = CN_EXPS[idx]; 
        }
        
        // 计算最终结果
        const result = coeff * Math.pow(10, base + j*48);
        return result.toString();
      }

      // 支持中国大数字单位的通用解析：优先大数字再退化为浮点
      function parseManualToNumber(val) {
        if (val == null) return null;
        if (typeof val === 'number') return val;
        const s = String(val).trim();
        if (!s) return null;
        const sci = parseChinaJiLocal(s);
        if (sci) {
          const n = parseFloat(sci);
          return isNaN(n) ? null : n;
        }
        const n = parseFloat(s);
        return isNaN(n) ? null : n;
      }
      // 格式化数字显示（纯数字 + 科学计数法 + 大数字）
      function formatNumberDisplay(value, digits=2) {
        if (!value || value === '-' || value === 0) return { raw: value || '0', sci: value || '0', cn: value || '0' };
        
        const num = parseFloat(value);
        if (!isFinite(num)) return { raw: '-', sci: '-', cn: '-' };
        
        // 纯数字格式
        let rawStr = num.toString();
        if (num >= 1e8) rawStr = ''; // 超过10^8不显示纯数字
        
        // 科学计数法格式
        const sciStr = num.toExponential(digits);
        
        // 大数字格式
        const cnStr = formatChinaJiLocal(num.toString(), digits);
        
        return { raw: rawStr, sci: sciStr, cn: cnStr };
      }

      function formatChinaJiLocal(expStr, digits=2){
        const s = String(expStr||'');
        
        // 处理纯数字格式（非科学计数法）
        if (/^\s*[-+]?\d+(?:\.\d+)?\s*$/.test(s)) {
          const num = parseFloat(s);
          if (!isFinite(num)) return '-';
          if (num < 10000) return num.toString();
          
          // 将纯数字转换为科学计数法处理
          const sciStr = num.toExponential();
          return formatChinaJiLocal(sciStr, digits);
        }
        
        // 处理科学计数法格式
        const m = s.match(/^\s*([-+]?\d+(?:\.\d+)?)e([-+]?\d+)\s*$/i);
        if (!m) return '-';
        
        let coeff = parseFloat(m[1]);
        let expo = parseInt(m[2], 10);
        
        // 如果系数或指数无法解析，返回原始字符串
        if (!isFinite(coeff) || !isFinite(expo)) {
          return s;
        }
        
        // 处理负数指数（小于1的数字）
        if (expo < 0) {
          return coeff.toFixed(digits);
        }
        
        // 处理超大指数（超过 JavaScript 安全范围）
        if (expo > 1000) {
          // 对于超大数字，直接使用科学计数法显示，不进行中国大数字转换
          return `${coeff.toFixed(digits)}e${expo}`;
        }
        
        // 归一化到 [1,10)
        while (coeff >= 10) { coeff /= 10; expo += 1; }
        while (coeff < 1 && coeff > 0) { coeff *= 10; expo -= 1; }
        if (coeff === 0) return '0';
        
        const ji = Math.floor(expo / 48);
        let rem = expo % 48; if (rem < 0) rem += 48; // 防御性处理
        let unit = '';
        let shift = rem;
        
        // 修复：确保能找到合适的单位
        for (let i = CN_EXPS.length - 1; i >= 0; i--) {
          if (rem >= CN_EXPS[i]) { 
            unit = CN_UNITS[i]; 
            shift = rem - CN_EXPS[i]; 
            break; 
          }
        }
        
        // 如果没有找到合适的单位，直接使用数字
        if (!unit && shift === 0) {
          return `${coeff.toFixed(digits)}${'极'.repeat(ji)}`;
        }
        
        const coeffAdj = coeff * Math.pow(10, shift);
        return `${coeffAdj.toFixed(digits)}${unit}${'极'.repeat(ji)}`;
      }

      function parseESci(str){
        const s = String(str||'');
        const m = s.match(/^\s*([-+]?\d+(?:\.\d+)?)e([-+]?\d+)\s*$/i);
        if (!m) return null;
        return { c: parseFloat(m[1]), e: parseInt(m[2],10) };
      }

      function compareStatusBySci(totalSci, targetSci){
        const a = parseESci(totalSci);
        const b = parseESci(targetSci);
        if (!a || !b) return null;
        if (a.e > b.e) return 'over5x';
        if (a.e < b.e) return 'under';
        // same exponent
        if (a.c >= 5 * b.c) return 'over5x';
        if (a.c >= b.c) return 'ok';
        return 'under';
      }
      const $ = (id) => document.getElementById(id);

      function setStatus(s) {
        const el = $('status');
        el.className = `status ${s}`;
        el.textContent = s;
      }

      async function computeWithForm(payloadOverride) {
        try {
          setStatus('计算中…');
          const basePayload = (() => {
            const levelConfig = { targetScore: $('targetScore').value.trim() };
            if (document.getElementById('kingEnabled') && document.getElementById('kingEnabled').checked) {
              levelConfig.kingCallInitialMultiplier = '1'; // 王之召唤初始番数固定为1
              const t = $('trigK') ? $('trigK').value.trim() : '4';
              if (t) levelConfig.kingCallTriggers = Number(t);
              levelConfig.kingCallBase = '30'; // 基础番数固定为30
            }
            const sequence = { baseScore: $('baseScore').value.trim(), items: [] };

            const options = {
              daoyinValue: $('daoyin').value.trim(),
              fuzhongValue: $('fuzhong').value.trim(),
              yueguangValue: $('yueguang').value.trim(),
              overrideTriggers: {
                daoyin: Number($('trigD').value.trim() || '0'),
                fuzhong: Number($('trigF').value.trim() || '0'),
                yueguang: Number($('trigY').value.trim() || '0'),
              },
              overrideTheoreticalMaxes: {
                daoyin: Number($('theoD').value.trim() || '0'),
                fuzhong: Number($('theoF').value.trim() || '0'),
                yueguang: Number($('theoY').value.trim() || '0'),
                kingCall: Number($('maxTrigK').value.trim() || '0') // 添加王之召唤理论最大触发次数
              }
            };
            return { levelConfig, sequence, options };
          })();
          if (!basePayload) return;

          const payload = payloadOverride ? { ...basePayload, ...payloadOverride } : basePayload;
          // 覆盖胡牌番数 - 如果有王之召唤，使用王之召唤计算出的胡牌番数
          const kingEnabled = document.getElementById('kingEnabled')?.checked;
          if (kingEnabled) {
            // 计算王之召唤乘数来替换胡牌番数
            const currentLevel = $('levelSelect')?.value || 'Ex61';
            const all = computeRecommendedAll();
            const levelData = all[currentLevel];
            
            if (levelData?.actualK && levelData?.actualKH) {
              const currentKingFan = levelData.actualK;
              const winCountFromSettings = parseFloat($('finalMulInput').value) || 1;
              const triggerCount = parseInt($('trigK').value) || 4;
              
              // 使用统一的王之召唤乘数计算函数
              const kingMultiplier = calculateKingCallMultiplier(currentKingFan, triggerCount, winCountFromSettings);
              
              // 使用王之召唤乘数直接替换胡牌番数
              // console.log('🎯 后端调用王之召唤计算:', {
              //   currentKingFan,
              //   winCountFromSettings,
              //   triggerCount,
              //   kingMultiplier,
              //   finalMultiplierOverride: kingMultiplier.toString()
              // });
              payload.options.finalMultiplierOverride = kingMultiplier.toString();
              
              // 如果王之召唤开启，还需要计算理论最大触发次数对应的王之召唤乘数
              const maxTrigK = parseInt($('maxTrigK').value) || 4;
              // console.log('🔍 前端王之召唤理论最大触发次数调试:', {
              //   currentKingFan,
              //   maxTrigK,
              //   winCountFromSettings,
              //   triggerCount
              // });
              
              if (maxTrigK > 0) {
                const theoreticalKingMultiplier = calculateKingCallMultiplier(currentKingFan, maxTrigK, winCountFromSettings);
                payload.options.theoreticalFinalMultiplierOverride = theoreticalKingMultiplier.toString();
                // console.log('🎯 前端计算王之召唤理论最大乘数:', theoreticalKingMultiplier.toString());
              } else {
                // 如果王之召唤理论最大触发次数为0，使用原始胡牌番数
                payload.options.theoreticalFinalMultiplierOverride = $('finalMulInput').value.trim();
                // console.log('🎯 王之召唤理论最大触发次数为0，使用原始胡牌番数:', $('finalMulInput').value.trim());
              }
            } else {
          payload.options.finalMultiplierOverride = $('finalMulInput').value.trim();
              // 王之召唤关闭时，理论最大乘数也使用原始胡牌番数
              payload.options.theoreticalFinalMultiplierOverride = $('finalMulInput').value.trim();
            }
          } else {
            payload.options.finalMultiplierOverride = $('finalMulInput').value.trim();
          }
          // 将三类番数输入也允许中文大数：预解析为科学计数
          ['daoyinValue','fuzhongValue','yueguangValue'].forEach(k=>{
            const v = payload.options[k];
            const p = parseChinaJiLocal(v);
            if (p) payload.options[k] = p;
          });
          // baseScore/targetScore 亦本地解析
          const pt = parseChinaJiLocal(payload.levelConfig.targetScore); if (pt) payload.levelConfig.targetScore = pt;
          const pb = parseChinaJiLocal(payload.sequence.baseScore); if (pb) payload.sequence.baseScore = pb;
          // 触发次数与理论最大次数确保为数字
          payload.options.overrideTriggers = payload.options.overrideTriggers || {};
          payload.options.overrideTheoreticalMaxes = payload.options.overrideTheoreticalMaxes || {};
          ['daoyin','fuzhong','yueguang','kingCall'].forEach(k=>{
            payload.options.overrideTriggers[k] = Number(payload.options.overrideTriggers[k]||0);
            payload.options.overrideTheoreticalMaxes[k] = Number(payload.options.overrideTheoreticalMaxes[k]||0);
          });

          const resp = await fetch(api, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload),
          });
          const data = await resp.json();
          const prec = getCurrentPrecision();
          $('resTotalSci').textContent = data.totalScore || '-';
          $('resTotalCn').textContent = data.totalScore ? formatChinaJiLocal(data.totalScore, prec) : '-';
          $('resTheoSci').textContent = data.theoreticalTotalScore || '-';
          $('resTheoCn').textContent = data.theoreticalTotalScore ? formatChinaJiLocal(data.theoreticalTotalScore, prec) : '-';
          $('resTargetSci').textContent = (payload.levelConfig && payload.levelConfig.targetScore) || '-';
          $('resTargetCn').textContent = (payload.levelConfig && payload.levelConfig.targetScore) ? formatChinaJiLocal(payload.levelConfig.targetScore, prec) : '-';
          const dv = data.breakdown?.daoyin?.value;
          const fv = data.breakdown?.fuzhong?.value;
          const yv = data.breakdown?.yueguang?.value;
          const dvSci = dv != null ? parseFloat(dv).toExponential(prec) : '-';
          const fvSci = fv != null ? parseFloat(fv).toExponential(prec) : '-';
          const yvSci = yv != null ? parseFloat(yv).toExponential(prec) : '-';
          const dvCn = dv != null ? formatChinaJiLocal(dvSci, getCurrentPrecision()) : '-';
          const fvCn = fv != null ? formatChinaJiLocal(fvSci, getCurrentPrecision()) : '-';
          const yvCn = yv != null ? formatChinaJiLocal(yvSci, getCurrentPrecision()) : '-';
          $('bdD').textContent = `番数=${dvSci} / ${dvCn}  触发=${data.breakdown?.daoyin?.triggers ?? '-'}`;
          $('bdF').textContent = `番数=${fvSci} / ${fvCn}  触发=${data.breakdown?.fuzhong?.triggers ?? '-'}`;
          $('bdY').textContent = `番数=${yvSci} / ${yvCn}  触发=${data.breakdown?.yueguang?.triggers ?? '-'}`;
          
          // 显示王之召唤调试信息
          /*
          const kingDebugEl = document.getElementById('kingSummonDebug');
          const kingDebugContentEl = document.getElementById('kingDebugContent');
          if (kingDebugEl && kingDebugContentEl) {
            const kingEnabled = document.getElementById('kingEnabled')?.checked;
            if (kingEnabled) {
              // 获取王之召唤相关参数
              const currentLevel = $('levelSelect')?.value || 'Ex61';
              const triggerCount = parseInt($('trigK')?.value) || 4; // 王之召唤实际触发次数
              
              // 获取该关卡的王之召唤番数和数值设置中的胡牌番数
              const all = computeRecommendedAll();
              const levelData = all[currentLevel];
              const currentKingFan = levelData?.actualK || 1; // 获取该关卡的王之召唤番数
              const winCountFromSettings = parseFloat($('finalMulInput')?.value) || 1; // 数值设置中的胡牌番数
              
              // 使用统一的王之召唤乘数计算函数
              const kingMultiplier = calculateKingCallMultiplier(currentKingFan, triggerCount, winCountFromSettings);
              
              // 显示调试信息
              kingDebugContentEl.innerHTML = `
                <div><strong>关卡:</strong> ${currentLevel}</div>
                <div><strong>当前关卡王之召唤番数:</strong> ${currentKingFan}</div>
                <div><strong>王之召唤实际触发次数:</strong> ${triggerCount}</div>
                <div><strong>数值设置中的胡牌番数:</strong> ${winCountFromSettings}</div>
                <div><strong>王之召唤乘数:</strong> ${kingMultiplier.toExponential(2)}</div>
                <div><strong>总分数:</strong> ${data.totalScore ? formatChinaJiLocal(data.totalScore, prec) : '-'}</div>
              `;
              kingDebugEl.style.display = 'block';
            } else {
              kingDebugEl.style.display = 'none';
            }
          */
            
            // 显示详细计算步骤调试信息
            /*
            const detailedDebugEl = document.getElementById('detailedCalculationDebug');
            const detailedDebugContentEl = document.getElementById('detailedDebugContent');
            if (detailedDebugEl && detailedDebugContentEl) {
              // 获取当前关卡数据
              const currentLevel = $('levelSelect')?.value || 'Ex61';
              const all = computeRecommendedAll();
              const levelData = all[currentLevel];
              
              // 获取各种参数
              const baseScore = parseFloat($('baseScore')?.value) || 0;
              const finalMultiplier = parseFloat($('finalMulInput')?.value) || 1;
              const trigD = parseInt($('trigD')?.value) || 0;
              const trigF = parseInt($('trigF')?.value) || 0;
              const trigY = parseInt($('trigY')?.value) || 0;
              const trigK = parseInt($('trigK')?.value) || 0;
              
              // 计算各种乘数（当番数为0时忽略该护身符）
              const daoyinMultiplier = (trigD === 0 || levelData.actualD === 0) ? 1 : Math.pow(levelData.actualD, trigD);
              const fuzhongMultiplier = (trigF === 0 || levelData.actualF === 0) ? 1 : Math.pow(levelData.actualF, trigF);
              const yueguangMultiplier = (trigY === 0 || levelData.actualY === 0) ? 1 : Math.pow(levelData.actualY, trigY);
              
              // 王之召唤乘数（当王之召唤番数为0时忽略）
              let kingMultiplier = 1;
              const kingEnabled = document.getElementById('kingEnabled')?.checked;
              if (kingEnabled && levelData.actualK && levelData.actualKH && levelData.actualK !== 0) {
                const currentKingFan = levelData.actualK;
                const winCountFromSettings = parseFloat($('finalMulInput').value) || 1;
                // 使用统一的王之召唤乘数计算函数
                kingMultiplier = calculateKingCallMultiplier(currentKingFan, trigK, winCountFromSettings);
              }
              
                // 计算最终总分
                let actualFinalMultiplier = finalMultiplier;
                if (kingEnabled && kingMultiplier > 1) {
                  // 王之召唤开启时，使用王之召唤乘数替换胡牌番数
                  actualFinalMultiplier = kingMultiplier;
                }
                const totalScore = baseScore * actualFinalMultiplier * daoyinMultiplier * fuzhongMultiplier * yueguangMultiplier;
              
              // 显示详细调试信息（改进数值格式化）
              const formatValue = (value) => {
                if (!isFinite(value) || value === Infinity || value === -Infinity) {
                  return 'Infinity';
                }
                // 对于所有数值，都尝试使用科学计数法显示，避免数值过大
                if (value > 1e6) {
                  return value.toExponential(2);
                }
                return value.toString();
              };
              
              // 专门用于显示最终总分的格式化函数
              const formatTotalScore = (value) => {
                if (!isFinite(value) || value === Infinity || value === -Infinity) {
                  return 'Infinity';
                }
                // 对于总分，如果数值过大，使用科学计数法显示
                if (value > 1e100) {
                  return value.toExponential(2);
                }
                // 否则直接显示数值，让浏览器自动处理
                return value.toString();
              };
              
              detailedDebugContentEl.innerHTML = `
                <div><strong>关卡:</strong> ${currentLevel}</div>
                <div><strong>基础参数:</strong></div>
                <div style="margin-left:10px;">小分分值: ${formatValue(baseScore)}</div>
                ${kingEnabled && kingMultiplier > 1 ? 
                  `<div style="margin-left:10px;">原始胡牌番数: ${formatValue(finalMultiplier)}</div>
                   <div style="margin-left:10px;">王之召唤替换后: ${formatValue(kingMultiplier)}</div>` :
                  `<div style="margin-left:10px;">胡牌番数: ${formatValue(finalMultiplier)}</div>`
                }
                <div><strong>各类番数:</strong></div>
                <div style="margin-left:10px;">盗印番数: ${formatValue(levelData.actualD)} (触发${trigD}次)</div>
                <div style="margin-left:10px;">负重番数: ${formatValue(levelData.actualF)} (触发${trigF}次)</div>
                <div style="margin-left:10px;">月光番数: ${formatValue(levelData.actualY)} (触发${trigY}次)</div>
                ${kingEnabled ? `<div style="margin-left:10px;">王之召唤番数: ${formatValue(levelData.actualK)} (触发${trigK}次)</div>` : ''}
                <div><strong>各乘数计算:</strong></div>
                <div style="margin-left:10px;">盗印乘数: ${formatValue(levelData.actualD)}^${trigD} = ${formatValue(daoyinMultiplier)}</div>
                <div style="margin-left:10px;">负重乘数: ${formatValue(levelData.actualF)}^${trigF} = ${formatValue(fuzhongMultiplier)}</div>
                <div style="margin-left:10px;">月光乘数: ${formatValue(levelData.actualY)}^${trigY} = ${formatValue(yueguangMultiplier)}</div>
                ${kingEnabled ? `<div style="margin-left:10px;">王之召唤乘数: ${formatValue(kingMultiplier)}</div>` : ''}
                <div><strong>最终计算:</strong></div>
                <div style="margin-left:10px;">总分 = ${formatValue(baseScore)} × ${formatValue(actualFinalMultiplier)} × ${formatValue(daoyinMultiplier)} × ${formatValue(fuzhongMultiplier)} × ${formatValue(yueguangMultiplier)}</div>
                <div style="margin-left:10px;">前端计算总分 = ${formatTotalScore(totalScore)}</div>
                <div style="margin-left:10px;">后端返回总分 = ${data.totalScore || '-'}</div>
                <div style="margin-left:10px;">后端返回总分中文 = ${data.totalScore ? formatChinaJiLocal(data.totalScore, getCurrentPrecision()) : '-'}</div>
              `;
              detailedDebugEl.style.display = 'block';
            } else {
              detailedDebugEl.style.display = 'none';
            }
            */
          
          const localStatus = compareStatusBySci(data.totalScore, payload.levelConfig?.targetScore);
          setStatus(localStatus || data.status || '完成');
        } catch (err) {
          $('resTotalSci').textContent = '-';
          $('resTotalCn').textContent = '-';
          $('resTheoSci').textContent = '-';
          $('resTheoCn').textContent = '-';
          $('resTargetSci').textContent = '-';
          $('resTargetCn').textContent = '-';
          $('bdD').textContent = String(err);
          $('bdF').textContent = '';
          $('bdY').textContent = '';
          setStatus('under');
        }
      }

      $('btn').addEventListener('click', async () => computeWithForm());

      // 增长类型选择功能已移除，不再需要按钮式单选绑定

      // 增长区间（每5关）编辑器
      const ivData = {}; // key -> { dType, fType, yType } - 保留给每页5项使用

      // 关卡目标分数据（你提供的 JSON）
      const LEVEL_TARGETS = {
        "1-1": "200","1-2": "400","1-3": "800","2-1": "1000","2-2": "1500","2-3": "2100","3-1": "3000","3-2": "4000","3-3": "5200","4-1": "7000","4-2": "9800","4-3": "15000","5-1": "22500","5-2": "33300","5-3": "50000","Ex1": "1000000","Ex2": "12000000","Ex3": "90750000","Ex4": "8.11亿","Ex5": "84.28亿","Ex6": "1003.54亿","Ex7": "1.35兆","Ex8": "20.56兆","Ex9": "348.31兆","Ex10": "6542.41兆","Ex11": "13.55京","Ex12": "308.54京","Ex13": "7681.69京","Ex14": "20.84垓","Ex15": "664.10垓","Ex16": "2.46秭","Ex17": "105.10秭","Ex18": "5154.00秭","Ex19": "28.82穰","Ex20": "1830.00穰","Ex21": "13.14沟","Ex22": "1066.00沟","Ex23": "9.72涧","Ex24": "994.10涧","Ex25": "11.38正","Ex26": "1456.00正","Ex27": "20.79载","Ex28": "3306.0载","Ex29": "58.49极","Ex30": "1.25万极","Ex31": "300.70万极","Ex32": "8.71亿极","Ex33": "2792.00亿极","Ex34": "108.20兆极","Ex35": "4.63京极","Ex36": "2398.00京极","Ex37": "136.90垓极","Ex38": "9.41秭极","Ex39": "7147.00秭极","Ex40": "708.60穰极","Ex41": "91.69沟极","Ex42": "15.46涧极","Ex43": "3.40正极","Ex44": "9734.00正极","Ex45": "3627.00载极","Ex46": "1759.00极极","Ex47": "1109.00万极极","Ex48": "910.80亿极极","Ex49": "972.20兆极极","Ex50": "1349.00京极极","Ex51": "2811.00垓极极","Ex52": "8787.00秭极极","Ex53": "4.12沟极极","Ex54": "28.99涧极极","Ex55": "306.00正极极","Ex56": "4844.00载极极","Ex57": "11.5万极极极","Ex58": "409.9亿极极极","Ex59": "2.19京极极极","Ex60": "175.50垓极极极","Ex61": "2.11穰极极极","Ex62": "380.79沟极极极","Ex63": "10.30正极极极","Ex64": "4180.00载极极极","Ex65": "254.4万极极极极","Ex66": "23.23兆极极极极","Ex67": "3.18垓极极极极","Ex68": "6538.00秭极极极极","Ex69": "2015.00沟极极极极","Ex70": "931.40正极极极极","Ex71": "645.80极极极极极","Ex72": "671.70亿极极极极极","Ex73": "1047.00京极极极极极","Ex74": "2452.00秭极极极极极","Ex75": "8608.00沟极极极极极","Ex76": "4.53载极极极极极","Ex77": "35.79万极极极极极极","Ex78": "424.00兆极极极极极极","Ex79": "5.70E+310","Ex80": "5.70E+318","Ex81": "5.70E+326","Ex82": "5.70E+334","Ex83": "5.70E+342","Ex84": "5.70E+350","Ex85": "5.70E+359","Ex86": "5.70E+368","Ex87": "5.70E+377","Ex88": "5.70E+386","Ex89": "5.70E+395","Ex90": "5.70E+405","Ex91": "5.70E+415","Ex92": "5.70E+425","Ex93": "5.70E+435","Ex94": "5.70E+445","Ex95": "5.70E+455","Ex96": "5.70E+466","Ex97": "5.70E+477","Ex98": "5.70E+488","Ex99": "5.70E+499","Ex100": "9.99E+510","Ex101": "9.99E+522","Ex102": "9.99E+534","Ex103": "9.99E+546","Ex104": "9.99E+558","Ex105": "9.99E+571","Ex106": "9.99E+584","Ex107": "9.99E+597","Ex108": "9.99E+611","Ex109": "9.99E+625","Ex110": "9.99E+639","Ex111": "9.99E+654","Ex112": "9.99E+669","Ex113": "9.99E+684","Ex114": "9.99E+699","Ex115": "9.99E+715","Ex116": "9.99E+731","Ex117": "9.99E+748","Ex118": "9.99E+765","Ex119": "9.99E+783","Ex120": "9.99E+801"
      };

      // 分页展示 + 增长/沿用/手填 + 关卡选择填充
      const PAGE_SIZE = 10;
      const entries = Object.entries(LEVEL_TARGETS);
      const keyOrder = entries.map(([k]) => k);
      // 回溯某关的生效类型：若当前关未显式设置，回溯到最近一次设置；再没有则用全局选择
      function resolveTypeAtIndex(kind, idx){
        let cur = kind==='d' ? growthChoice.daoyin : kind==='f' ? growthChoice.fuzhong : growthChoice.yueguang;
        for (let i=0;i<=idx;i++){
          const k = keyOrder[i];
          const row = ivData[k];
          if (!row) continue;
          if (kind==='d' && row.dType) cur = row.dType;
          if (kind==='f' && row.fType) cur = row.fType;
          if (kind==='y' && row.yType) cur = row.yType;
        }
        return cur;
      }
      const levelsState = {}; // key -> { lockD, lockF, lockY, lockK, manuD, manuF, manuY, manuK, manuKH }

      const GROWTH = {
        daoyin: {
          '普通盗印': Math.pow(1.3, 1),
          '天使盗印': 1.6,
          '膨胀盗印': Math.pow(1.3, 2),
          '膨胀盗印吃卡维': Math.pow(1.3, 4),
        },
        fuzhong: {
          '普通负重': Math.pow(1.5, 1),
          '天使负重': 2.0,
          '膨胀负重': Math.pow(1.5, 2),
        },
        yueguang: {
          '普通月光': Math.pow(1.5, 1),
          '天使月光': 2.0,
          '膨胀月光': Math.pow(1.5, 2),
        }
      };

      let growthChoice = { daoyin: '普通盗印', fuzhong: '普通负重', yueguang: '普通月光' };

      // 统一的王之召唤乘数计算函数
      function calculateKingCallMultiplier(currentKingFan, triggerCount, winCountFromSettings) {
        if (!currentKingFan || !triggerCount) return 1;
        
        // 计算EffectiveFan = 14 × 当前关卡的王之召唤番数
        const effectiveFan = 14 * currentKingFan;
        
        // 计算FinalFan = (EffectiveFan + 10 + 数值设置中的胡牌番数)
        const finalFan = effectiveFan + 10 + winCountFromSettings;
        
        // 最终连乘：FinalFan × (当前王之召唤番数+1) × (当前王之召唤番数+2) × ... × (当前王之召唤番数+触发次数)
        let kingMultiplier = finalFan;
        for (let k = currentKingFan + 1; k <= currentKingFan + triggerCount; k++) {
          kingMultiplier *= k;
        }
        
        return kingMultiplier;
      }

      function computeRecommendedAll() {
        const result = {};
        let prev = { d: 1, f: 1, y: 1, k: 1 }; // 添加王之召唤初始番数
        
        // 如果是从存档加载，尝试从levelsState中恢复prev.k的初始值
        const firstEx61Index = keyOrder.indexOf('Ex61');
        if (firstEx61Index > 0) {
          // 检查Ex61之前是否有王之召唤数据
          for (let i = 0; i < firstEx61Index; i++) {
            const key = keyOrder[i];
            const st = levelsState[key] || {};
            if (st.recK !== undefined && st.recK !== null) {
              prev.k = st.recK;
              break;
            }
          }
        }
        
        const uD = $('unlockD').value; const uF = $('unlockF').value; const uY = $('unlockY').value;
        const idxD = keyOrder.indexOf(uD); const idxF = keyOrder.indexOf(uF); const idxY = keyOrder.indexOf(uY);

        // 王之召唤：支持手动从任意关卡开始级联
        const ex61Index = keyOrder.indexOf('Ex61');
        let manualKStartIndex = -1;
        let manualKStartValue = null;
        for (let i = 0; i < keyOrder.length; i++) {
          const key = keyOrder[i];
          const st = levelsState[key] || {};
          const parsedK = parseManualToNumber(st.manuK);
          if (parsedK != null && parsedK > 0) {
            manualKStartIndex = i;
            manualKStartValue = parsedK;
            break;
          }
        }
        
        for (let i = 0; i < keyOrder.length; i++) {
          const key = keyOrder[i];
          const st = levelsState[key] || {};
          const ivRow = ivData[key] || {};
          
          // 优先使用 ivData 中的增长类型，否则使用全局默认
          const dType = ivRow.dType || growthChoice.daoyin;
          const fType = ivRow.fType || growthChoice.fuzhong;
          const yType = ivRow.yType || growthChoice.yueguang;
          
          const gd = GROWTH.daoyin[dType] || 1.3;
          const gf = GROWTH.fuzhong[fType] || 1.5;
          const gy = GROWTH.yueguang[yType] || 1.5;

          // 计算解锁与成长：解锁关为 1 番；解锁后下一关开始成长
          const recD = (i === idxD) ? 1 : (i < idxD || idxD<0) ? 0 : (st.lockD ? prev.d : prev.d * gd);
          const recF = (i === idxF) ? 1 : (i < idxF || idxF<0) ? 0 : (st.lockF ? prev.f : prev.f * gf);
          const recY = (i === idxY) ? 1 : (i < idxY || idxY<0) ? 0 : (st.lockY ? prev.y : prev.y * gy);

          // 王之召唤计算逻辑（支持手动起始级联）
          let recK = 0; // 默认 0
          const kStartIndex = (manualKStartIndex !== -1) ? manualKStartIndex : ex61Index;
          if (kStartIndex >= 0) {
            if (i < kStartIndex) {
              recK = 0;
            } else if (i === kStartIndex) {
              recK = (manualKStartIndex !== -1) ? manualKStartValue : 1; // 手动起始用手动值，否则 Ex61 默认 1
            } else {
              recK = prev.k; // 之后使用上一关的实际番数作为基础
            }
          }
          
          // 如果手动设置了番数，recK保持不变，actualK会使用手动设置的值

          const actualD = st.manuD ? parseFloat(st.manuD) : recD;
          const actualF = st.manuF ? parseFloat(st.manuF) : recF;
          const actualY = st.manuY ? parseFloat(st.manuY) : recY;
          const actualK = st.manuK ? parseFloat(st.manuK) : recK;
          const actualKH = st.manuKH ? parseInt(st.manuKH) : (st.recKH || 1); // 胡牌次数，优先使用recKH，默认1
          
          // 确保推荐值被保存到levelsState中（用于历史数据保存）
          if (st.manuK === undefined && recK !== 0) {
            levelsState[key] = levelsState[key] || {};
            levelsState[key].recK = recK; // 保存推荐值
          }
          if (st.manuKH === undefined) {
            levelsState[key] = levelsState[key] || {};
            levelsState[key].recKH = actualKH; // 保存推荐胡牌次数
          }

          // 计算下一关的王之召唤番数：当前番数 +（触发次数 × 胡牌次数）
          const triggerCount = parseInt($('trigK').value) || 4; // 使用王之召唤专用的触发次数，默认4次
          const nextK = actualK + (triggerCount * actualKH);

          result[key] = { 
            recD, recF, recY, recK,
            actualD, actualF, actualY, actualK, actualKH,
            nextK // 下一关的王之召唤番数
          };
          prev = { d: actualD, f: actualF, y: actualY, k: nextK };
        }
        return result;
      }

  // ===== 存储/读取 每关番数与增长类型 =====
  // 全局 Alert 栈与工具
  function ensureAlertStack(){
    let s = document.getElementById('alertStack');
    if (!s){
      s = document.createElement('div');
      s.id = 'alertStack';
      s.className = 'alert-stack';
      document.body.appendChild(s);
    }
    return s;
  }
  function showAlert(kind, text){
    const s = ensureAlertStack();
    const el = document.createElement('div');
    el.className = 'alert ' + (kind||'');
    el.innerHTML = `<span>${text}</span><button class="close">×</button>`;
    el.querySelector('.close').addEventListener('click', ()=> el.remove());
    s.appendChild(el);
    setTimeout(()=>{ el.remove(); }, 3000);
  }
  const STORAGE_KEY = 'qyzz_level_data_v1'; // 单槽旧键，保留兼容
  const STORAGE_KEYS_MULTI = 'qyzz_level_data_multi_v1'; // 多槽管理
  const STORAGE_MULTI_KEY = 'qyzz_level_data_multi_v1';
  function snapshotLevelData(){
    const all = computeRecommendedAll();
    const data = { 
      levels: {}, 
      growthDefault: growthChoice,
      kingSummon: {
        enabled: document.getElementById('kingEnabled')?.checked || false,
        actualTriggers: parseInt($('trigK')?.value) || 4,
        maxTriggers: parseInt($('maxTrigK')?.value) || 4
      }
    };
    for (const key of keyOrder){
      const st = levelsState[key] || {};
      const ivRow = ivData[key] || {};
      const a = all[key] || {};
      data.levels[key] = {
        manuD: st.manuD ?? null,
        manuF: st.manuF ?? null,
        manuY: st.manuY ?? null,
        manuK: st.manuK ?? null,
        manuKH: st.manuKH ?? null,
        recK: st.recK ?? null,
        recKH: st.recKH ?? null,
        lockD: !!st.lockD,
        lockF: !!st.lockF,
        lockY: !!st.lockY,
        lockK: !!st.lockK,
        dType: ivRow.dType || null,
        fType: ivRow.fType || null,
        yType: ivRow.yType || null,
        recD: a.recD ?? null,
        recF: a.recF ?? null,
        recY: a.recY ?? null,
        recK: a.recK ?? null,
        actualD: a.actualD ?? null,
        actualF: a.actualF ?? null,
        actualY: a.actualY ?? null,
        actualK: a.actualK ?? null,
        actualKH: a.actualKH ?? null,
      };
    }
    return data;
  }

  function saveCurrentLevelData(){
    try{
      const data = snapshotLevelData();
      // 写入多槽：需要名称
      const name = (document.getElementById('historyName')?.value || '').trim();
      if (!name){ showAlert('alert-warn','请输入名称'); return; }
      const multiRaw = localStorage.getItem(STORAGE_KEYS_MULTI);
      const multi = multiRaw ? JSON.parse(multiRaw) : {};
      multi[name] = { t: Date.now(), data };
      localStorage.setItem(STORAGE_KEYS_MULTI, JSON.stringify(multi));
      populateHistorySelect();
      const sel = document.getElementById('historySelect'); if (sel) sel.value = name;
      showAlert('alert-ok','已保存：' + name);
    }catch(e){
      console.error('保存失败', e);
      showAlert('alert-danger','保存失败');
    }
  }

  function loadHistoryLevelData(){
    try{
      const sel = document.getElementById('historySelect');
      const key = sel ? sel.value : '';
      const multiRaw = localStorage.getItem(STORAGE_KEYS_MULTI);
      const multi = multiRaw ? JSON.parse(multiRaw) : {};
      const obj = multi[key];
      const data = obj && obj.data;
      if(!data || !data.levels){ showAlert('alert-danger','历史数据格式不正确'); return; }
      // 恢复默认增长选择
      if (data.growthDefault){
        growthChoice = { ...growthChoice, ...data.growthDefault };
      }
      
      // 恢复王之召唤设置
      if (data.kingSummon) {
        const kingEnabled = document.getElementById('kingEnabled');
        if (kingEnabled) {
          kingEnabled.checked = data.kingSummon.enabled || false;
          // 触发王之召唤开关事件，显示/隐藏相关UI
          kingEnabled.dispatchEvent(new Event('change'));
        }
        const trigKInput = document.getElementById('trigK');
        if (trigKInput) {
          trigKInput.value = data.kingSummon.actualTriggers || 4;
        }
        const maxTrigKInput = document.getElementById('maxTrigK');
        if (maxTrigKInput) {
          maxTrigKInput.value = data.kingSummon.maxTriggers || 4;
        }
      }
      // 恢复 per-level 状态与增长类型
      for (const key of Object.keys(data.levels)){
        const v = data.levels[key] || {};
        levelsState[key] = levelsState[key] || {};
        ivData[key] = ivData[key] || {};
        // 恢复手动/沿用
        levelsState[key].manuD = v.manuD ?? null;
        levelsState[key].manuF = v.manuF ?? null;
        levelsState[key].manuY = v.manuY ?? null;
        levelsState[key].manuK = v.manuK ?? null;
        levelsState[key].manuKH = v.manuKH ?? null;
        levelsState[key].recK = v.recK ?? null;
        levelsState[key].recKH = v.recKH ?? null;
        levelsState[key].lockD = !!v.lockD;
        levelsState[key].lockF = !!v.lockF;
        levelsState[key].lockY = !!v.lockY;
        levelsState[key].lockK = !!v.lockK;
        // 恢复增长类型
        if (v.dType) ivData[key].dType = v.dType;
        if (v.fType) ivData[key].fType = v.fType;
        if (v.yType) ivData[key].yType = v.yType;
      }
      renderPage5();
      showAlert('alert-ok','已读取：' + key);
    }catch(e){
      console.error('读取失败', e);
      showAlert('alert-danger','读取失败');
    }
  }

  function deleteHistory(){
    const sel = document.getElementById('historySelect');
    const key = sel ? sel.value : '';
    if (!key){ showAlert('alert-warn','请选择要删除的配置'); return; }
    if (!confirm(`确认删除历史配置“${key}”吗？该操作不可撤销。`)) return;
    try{
      const multiRaw = localStorage.getItem(STORAGE_KEYS_MULTI);
      const multi = multiRaw ? JSON.parse(multiRaw) : {};
      delete multi[key];
      localStorage.setItem(STORAGE_KEYS_MULTI, JSON.stringify(multi));
      populateHistorySelect();
      showAlert('alert-ok','已删除：' + key);
    }catch(e){
      console.error('删除失败', e);
      showAlert('alert-danger','删除失败');
    }
  }

  function populateHistorySelect(){
    const sel = document.getElementById('historySelect');
    if (!sel) return;
    const multiRaw = localStorage.getItem(STORAGE_KEYS_MULTI);
    const multi = multiRaw ? JSON.parse(multiRaw) : {};
    const current = sel.value;
    sel.innerHTML = '<option value="">选择历史配置</option>' +
      Object.keys(multi).sort().map(k=>`<option value="${k}">${k}</option>`).join('');
    if (current && multi[current]) sel.value = current;
  }

  // ===== 多份历史配置 =====
  function readAllSlots(){
    try{ return JSON.parse(localStorage.getItem(STORAGE_MULTI_KEY)||'{}'); }catch{ return {}; }
  }
  function writeAllSlots(obj){
    localStorage.setItem(STORAGE_MULTI_KEY, JSON.stringify(obj));
  }
  function refreshHistorySelect(){
    const sel = document.getElementById('historySelect');
    if (!sel) return;
    const all = readAllSlots();
    const current = sel.value;
    sel.innerHTML = '<option value="">选择历史配置</option>' + Object.keys(all).map(k=>`<option value="${k}">${k}</option>`).join('');
    if (current && all[current]) sel.value = current;
  }
  function saveNamedSlot(){
    const name = (document.getElementById('historyName')?.value||'').trim();
    if (!name){ alert('请输入名称'); return; }
    const all = readAllSlots();
    all[name] = { t: Date.now(), data: snapshotLevelData() };
    writeAllSlots(all);
    refreshHistorySelect();
    alert('已命名保存');
  }
  function loadNamedSlot(){
    const sel = document.getElementById('historySelect');
    const key = sel?.value||'';
    if (!key){ return; }
    const all = readAllSlots();
    const slot = all[key];
    if (!slot){ alert('未找到该配置'); return; }
    const obj = slot.data;
    if (!obj || !obj.levels){ alert('历史数据格式不正确'); return; }
    // 复用单槽加载逻辑
    const data = { data: obj };
    localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
    loadHistoryLevelData();
  }
  function deleteNamedSlot(){
    const sel = document.getElementById('historySelect');
    const key = sel?.value||'';
    if (!key){ alert('请选择要删除的配置'); return; }
    const all = readAllSlots();
    if (!all[key]){ alert('未找到该配置'); return; }
    delete all[key];
    writeAllSlots(all);
    refreshHistorySelect();
    alert('已删除配置');
  }

      // renderPage函数已删除，因为"每页10项"区块已被移除
      function renderAll(){ /* 不再需要 */ }
      // 解锁关卡下拉填充
      function fillUnlockSelects(){
        // 仅提供 1-1 ~ Ex10 的关卡供选择
        const ex10Idx = keyOrder.indexOf('Ex10');
        const allowKeys = ex10Idx >= 0 ? keyOrder.slice(0, ex10Idx + 1) : keyOrder;
        const opts = allowKeys.map(k=>`<option value="${k}">${k}</option>`).join('');
        $('unlockD').innerHTML = opts;
        $('unlockF').innerHTML = opts;
        $('unlockY').innerHTML = opts;
        // 默认值：盗印3-1、负重4-2、月光3-3 若存在，否则置为首关
        const fallback = keyOrder[0];
        const setIfExists = (elId, key)=>{ const el=$(elId); el.value = keyOrder.includes(key)? key : fallback; };
        setIfExists('unlockD','1-1'); setIfExists('unlockF','1-2'); setIfExists('unlockY','1-3');
      }
      fillUnlockSelects();
      // 确认起始关后，刷新右侧联动
      document.getElementById('unlockApply').addEventListener('click', ()=>{
        renderPage5();
      });

      // 关卡下拉
      const sel = $('levelSelect');
      sel.innerHTML = keyOrder.map(k => `<option value="${k}">${k}</option>`).join('');
      sel.addEventListener('change', () => {
        const k = sel.value;
        $('targetScore').value = LEVEL_TARGETS[k];
        
        // 联动读取关卡目标分模块的番数并填充到数值设置模块
        const all = computeRecommendedAll();
        const levelData = all[k];
        if (levelData) {
          $('daoyin').value = `${(levelData.actualD || 0).toFixed(6)}`;
          $('fuzhong').value = `${(levelData.actualF || 0).toFixed(6)}`;
          $('yueguang').value = `${(levelData.actualY || 0).toFixed(6)}`;
          // 同步刷新右下角格式显示
          updateStampDisplay();
        }
      });
      $('prevLevel').addEventListener('click', ()=>{ const idx=keyOrder.indexOf(sel.value); if(idx>0){ sel.value=keyOrder[idx-1]; sel.dispatchEvent(new Event('change')); }});
      $('nextLevel').addEventListener('click', ()=>{ const idx=keyOrder.indexOf(sel.value); if(idx>=0 && idx<keyOrder.length-1){ sel.value=keyOrder[idx+1]; sel.dispatchEvent(new Event('change')); }});

      // 新的每页6项列表，完全参照每页10项的成功模式
      const PAGE5 = 6;
      let page5 = 0;
      // 防止输入框 blur 触发的重渲染抢先于“确认手动输入变更”点击，导致首次点击无效
      let suppressRenderOnBlur = false;
      let currentLayout = 'single'; // 'single' 或 'two-column'

      // 获取网格类名
      function getGridClass(isMoonlightEnabled, isFuzhongEnabled, isKingEnabled) {
        let columnCount = 1; // 基础：盗印
        if (isFuzhongEnabled) columnCount++; // 负重
        if (isMoonlightEnabled) columnCount++; // 月光
        if (isKingEnabled) columnCount++; // 王之召唤
        return `grid-${columnCount}`;
      }

      // 行内未保存修改的暂存（按渲染用的 rowId 归档），用于：
      // 1) 失焦/重渲染后仍保留输入值
      // 2) 高亮展示哪些输入已修改
      // 3) 点击“确认手动输入变更”后统一提交并清空高亮
      const pendingEditsByRowId = {};

      function setPending(rowId, fieldKey, rawValue) {
        if (!pendingEditsByRowId[rowId]) pendingEditsByRowId[rowId] = {};
        pendingEditsByRowId[rowId][fieldKey] = rawValue;
      }

      function getPending(rowId, fieldKey) {
        return pendingEditsByRowId[rowId] ? pendingEditsByRowId[rowId][fieldKey] : undefined;
      }

      function clearPendingRow(rowId) {
        if (pendingEditsByRowId[rowId]) delete pendingEditsByRowId[rowId];
      }

      // 根据输入框 id 解析 rowId 与字段键
      function parseInputId(inputId) {
        // 支持多字符前缀（KH 必须优先于 K）
        const m = inputId.match(/^g5(KH|D|F|Y|K)_([A-Za-z0-9_]+)$/);
        if (!m) return { rowId: '', field: '' };
        return { rowId: m[2], field: m[1] };
      }

      function getInputClassById(inputId) {
        const { rowId, field } = parseInputId(inputId);
        const pending = getPending(rowId, field);
        return pending != null && String(pending).trim() !== '' ? 'modified-input' : '';
      }

      // 获取输入框显示值的函数，优先使用用户的原始输入（中文单位）
      function getInputDisplayValue(actualValue, inputId) {
        // 先检查是否存在未保存的暂存值
        const { rowId, field } = parseInputId(inputId);
        const pending = getPending(rowId, field);
        if (pending != null && String(pending).trim() !== '') return pending;
        // 否则使用解析后的数值；胡牌次数为整数，其它保留小数
        if (field === 'KH') {
          const v = actualValue == null ? 1 : parseInt(actualValue);
          return String(isNaN(v) ? 1 : v);
        }
        return (actualValue || 0).toFixed(4);
      }

      function renderPage5(){
        const start = page5 * PAGE5;
        const keys = keyOrder.slice(start, start + PAGE5);
        const all = computeRecommendedAll();
        const mode = 'both'; // 固定使用both模式
        
        // 检查月光开关状态
        const moonlightToggle = document.getElementById('moonlightToggle');
        const isMoonlightEnabled = moonlightToggle ? moonlightToggle.checked : true;
        
        // 检查负重开关状态
        const fuzhongToggle = document.getElementById('fuzhongToggle');
        const isFuzhongEnabled = fuzhongToggle ? fuzhongToggle.checked : true;
        
        // 检查王之召唤开关状态
        const kingToggle = document.getElementById('kingEnabled');
        const isKingEnabled = kingToggle ? kingToggle.checked : false;
        
        let html = '';
        
        if (currentLayout === 'single') {
          // 单行布局：每个关卡占一整行
          html = keys.map((k, index)=>{
          const vSci = parseChinaJiLocal(LEVEL_TARGETS[k]) || LEVEL_TARGETS[k];
          const vCn = parseChinaJiLocal(LEVEL_TARGETS[k]) ? formatChinaJiLocal(parseChinaJiLocal(LEVEL_TARGETS[k]), getCurrentPrecision()) : LEVEL_TARGETS[k];
          const vDisp = mode==='sci'? vSci : mode==='cn'? vCn : `${vSci} / ${vCn}`;
          const a = all[k];
          const rowId = k.replace(/[^a-zA-Z0-9]/g,'_');
          const st = levelsState[k] || {};
          
          return `
            <div style="border-bottom:1px solid #eee; padding:12px 0;">
              ${index === 0 ? `
              <!-- 盗印、负重、月光、王之召唤标题（只在每页第一关显示） -->
              <div class="${getGridClass(isMoonlightEnabled, isFuzhongEnabled, isKingEnabled)}" style="margin-bottom:12px; font-weight:600; color:var(--text); text-align:center;">
                <div style="padding:4px;">盗印</div>
                ${isFuzhongEnabled ? '<div style="padding:4px;">负重</div>' : ''}
                ${isMoonlightEnabled ? '<div style="padding:4px;">月光</div>' : ''}
                ${isKingEnabled ? '<div style="padding:4px;">王之召唤</div>' : ''}
              </div>
              ` : ''}
              
              <div style="display:flex; justify-content:space-between; align-items:center; gap:8px;">
                <strong>${k}</strong>
                <span style="color:#6b7280;">目标分数：${vDisp}</span>
                <div style="display:flex; gap:8px;">
                  <button type="button" data-confirm5="${k}" class="btn-light">确认手动输入变更</button>
                  <button type="button" data-calc5="${k}">用本关参数计算</button>
                </div>
              </div>
              
              <div class="${getGridClass(isMoonlightEnabled, isFuzhongEnabled, isKingEnabled)}" style="margin-top:6px;">
                <div>
                  <!-- 番数输入行 -->
                  <div style="display:flex; align-items:center; gap:8px; margin-bottom:6px;">
                    <span style="font-size:12px;color:#374151; min-width:40px;">番数:</span>
                    <input type="text" id="g5D_${rowId}" name="g5D_${rowId}" value="${getInputDisplayValue(a.actualD, `g5D_${rowId}`)}" class="${getInputClassById(`g5D_${rowId}`)}" style="flex:1; padding:4px;" />
                  </div>
                  <div id="g5D_display_${rowId}" style="font-size:10px; color:#9ca3af; margin:2px 0 6px 44px; min-height:12px;">
                    ${(() => {
                      const formats = formatNumberDisplay((a.actualD||0), 2);
                      let displayText = '';
                      if (formats.raw) displayText += formats.raw;
                      if (formats.raw && formats.sci) displayText += ' / ';
                      if (formats.sci) displayText += formats.sci;
                      if (formats.cn && (a.actualD||0) >= 10000) {
                        displayText += ' / ' + formats.cn;
                      }
                      return displayText;
                    })()}
                  </div>
                  <!-- 按钮和推荐行 -->
                  <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:6px;">
                    <small style="color:#6b7280;">推荐: ${(() => {
                      const val = (a.recD||0);
                      return val >= 10000 ? val.toExponential(2) : val.toFixed(2);
                    })()}</small>
                    <div class="btn-group" style="display:flex; gap:4px;">
                      <button type="button" class="btn-radio tag-d btn-tooltip" data-growth5="d:${k}:普通盗印" data-gtype="普通盗印" data-tooltip="普通盗印1.3">普通盗印</button>
                      <button type="button" class="btn-radio tag-d alt btn-tooltip" data-growth5="d:${k}:天使盗印" data-gtype="天使盗印" data-tooltip="天使盗印1.6">天使盗印</button>
                      <button type="button" class="btn-radio tag-d btn-tooltip" data-growth5="d:${k}:膨胀盗印" data-gtype="膨胀盗印" data-tooltip="膨胀盗印1.3^2">膨胀盗印</button>
                      <button type="button" class="btn-radio tag-d alt btn-tooltip" data-growth5="d:${k}:膨胀盗印吃卡维" data-gtype="膨胀盗印吃卡维" data-tooltip="膨胀盗印吃卡维1.3^4">膨胀盗印吃卡维</button>
                    </div>
                    <button type="button" class="btn-tooltip" data-lock5d="${k}" style="font-size:11px; padding:2px 6px;" data-tooltip="${st.lockD ? '取消沿用' : '沿用上一关'}">${st.lockD ? '取消沿用' : '沿用上一关'}</button>
                  </div>
                </div>
                ${isFuzhongEnabled ? `
                <div>
                  <!-- 番数输入行 -->
                  <div style="display:flex; align-items:center; gap:8px; margin-bottom:6px;">
                    <span style="font-size:12px;color:#374151; min-width:40px;">番数:</span>
                    <input type="text" id="g5F_${rowId}" name="g5F_${rowId}" value="${getInputDisplayValue(a.actualF, `g5F_${rowId}`)}" class="${getInputClassById(`g5F_${rowId}`)}" style="flex:1; padding:4px;" />
                  </div>
                  <div id="g5F_display_${rowId}" style="font-size:10px; color:#9ca3af; margin:2px 0 6px 44px; min-height:12px;">
                    ${(() => {
                      const formats = formatNumberDisplay((a.actualF||0), 2);
                      let displayText = '';
                      if (formats.raw) displayText += formats.raw;
                      if (formats.raw && formats.sci) displayText += ' / ';
                      if (formats.sci) displayText += formats.sci;
                      if (formats.cn && (a.actualF||0) >= 10000) {
                        displayText += ' / ' + formats.cn;
                      }
                      return displayText;
                    })()}
                  </div>
                  <!-- 按钮和推荐行 -->
                  <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:6px;">
                    <small style="color:#6b7280;">推荐: ${(() => {
                      const val = (a.recF||0);
                      return val >= 10000 ? val.toExponential(2) : val.toFixed(2);
                    })()}</small>
                    <div class="btn-group" style="display:flex; gap:4px;">
                      <button type="button" class="btn-radio tag-f btn-tooltip" data-growth5="f:${k}:普通负重" data-gtype="普通负重" data-tooltip="普通负重1.5">普通负重</button>
                      <button type="button" class="btn-radio tag-f alt btn-tooltip" data-growth5="f:${k}:天使负重" data-gtype="天使负重" data-tooltip="天使负重2">天使负重</button>
                      <button type="button" class="btn-radio tag-f btn-tooltip" data-growth5="f:${k}:膨胀负重" data-gtype="膨胀负重" data-tooltip="膨胀负重2.25">膨胀负重</button>
                    </div>
                    <button type="button" class="btn-tooltip" data-lock5f="${k}" style="font-size:11px; padding:2px 6px;" data-tooltip="${st.lockF ? '取消沿用' : '沿用上一关'}">${st.lockF ? '取消沿用' : '沿用上一关'}</button>
                  </div>
                </div>
                ` : ''}
                ${isMoonlightEnabled ? `
                <div>
                  <!-- 番数输入行 -->
                  <div style="display:flex; align-items:center; gap:8px; margin-bottom:6px;">
                    <span style="font-size:12px;color:#374151; min-width:40px;">番数:</span>
                    <input type="text" id="g5Y_${rowId}" name="g5Y_${rowId}" value="${getInputDisplayValue(a.actualY, `g5Y_${rowId}`)}" class="${getInputClassById(`g5Y_${rowId}`)}" style="flex:1; padding:4px;" />
                  </div>
                  <div id="g5Y_display_${rowId}" style="font-size:10px; color:#9ca3af; margin:2px 0 6px 44px; min-height:12px;">
                    ${(() => {
                      const formats = formatNumberDisplay((a.actualY||0), 2);
                      let displayText = '';
                      if (formats.raw) displayText += formats.raw;
                      if (formats.raw && formats.sci) displayText += ' / ';
                      if (formats.sci) displayText += formats.sci;
                      if (formats.cn && (a.actualY||0) >= 10000) {
                        displayText += ' / ' + formats.cn;
                      }
                      return displayText;
                    })()}
                  </div>
                  <!-- 按钮和推荐行 -->
                  <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:6px;">
                    <small style="color:#6b7280;">推荐: ${(() => {
                      const val = (a.recY||0);
                      return val >= 10000 ? val.toExponential(2) : val.toFixed(2);
                    })()}</small>
                    <div class="btn-group" style="display:flex; gap:4px;">
                      <button type="button" class="btn-radio tag-y btn-tooltip" data-growth5="y:${k}:普通月光" data-gtype="普通月光" data-tooltip="普通月光1.5">普通月光</button>
                      <button type="button" class="btn-radio tag-y alt btn-tooltip" data-growth5="y:${k}:天使月光" data-gtype="天使月光" data-tooltip="天使月光2">天使月光</button>
                      <button type="button" class="btn-radio tag-y btn-tooltip" data-growth5="y:${k}:膨胀月光" data-gtype="膨胀月光" data-tooltip="膨胀月光2.25">膨胀月光</button>
                    </div>
                    <button type="button" class="btn-tooltip" data-lock5y="${k}" style="font-size:11px; padding:2px 6px;" data-tooltip="${st.lockY ? '取消沿用' : '沿用上一关'}">${st.lockY ? '取消沿用' : '沿用上一关'}</button>
                  </div>
                </div>
                ` : ''}
                ${isKingEnabled ? `
                <div>
                  <!-- 王之召唤番数和胡牌在同一行 -->
                  <div style="display:flex; gap:8px; margin-bottom:6px;">
                    <div style="flex:1;">
                      <div style="display:flex; align-items:center; gap:4px;">
                        <span style="font-size:12px;color:#374151; min-width:30px;">番数:</span>
                        <input type="text" id="g5K_${rowId}" name="g5K_${rowId}" value="${getInputDisplayValue(a.actualK, `g5K_${rowId}`)}" class="${getInputClassById(`g5K_${rowId}`)}" style="flex:1; padding:4px;" />
                      </div>
                      <div id="g5K_display_${rowId}" style="font-size:10px; color:#9ca3af; margin:2px 0 0 34px; min-height:12px;">
                        ${(() => {
                          const formats = formatNumberDisplay((a.actualK||0), 2);
                          let displayText = '';
                          if (formats.raw) displayText += formats.raw;
                          if (formats.raw && formats.sci) displayText += ' / ';
                          if (formats.sci) displayText += formats.sci;
                          if (formats.cn && (a.actualK||0) >= 10000) {
                            displayText += ' / ' + formats.cn;
                          }
                          return displayText;
                        })()}
                      </div>
                    </div>
                    <div style="flex:1;">
                      <div style="display:flex; align-items:center; gap:4px;">
                        <span style="font-size:12px;color:#374151; min-width:30px;">胡牌:</span>
                        <input type="number" id="g5KH_${rowId}" name="g5KH_${rowId}" value="${getInputDisplayValue(a.actualKH, `g5KH_${rowId}`)}" class="${getInputClassById(`g5KH_${rowId}`)}" min="1" style="flex:1; padding:4px;" />
                      </div>
                      <div id="g5KH_display_${rowId}" style="font-size:10px; color:#9ca3af; margin:2px 0 0 34px; min-height:12px;">
                        <!-- 胡牌次数不需要显示大数字格式，因为它是整数 -->
                      </div>
                    </div>
                  </div>
                  <!-- 按钮和推荐行 -->
                  <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:6px;">
                    <small style="color:#6b7280;">推荐: ${(() => {
                      const val = (a.recK||0);
                      return val >= 10000 ? val.toExponential(2) : val.toFixed(2);
                    })()}</small>
                    <button type="button" class="btn-tooltip" data-lock5k="${k}" style="font-size:11px; padding:2px 6px;" data-tooltip="${st.lockK ? '取消沿用' : '沿用上一关'}">${st.lockK ? '取消沿用' : '沿用上一关'}</button>
                  </div>
                </div>
                ` : ''}
              </div>
            </div>
          `;
        }).join('');
        
        } else if (currentLayout === 'two-column') {
          // 两栏布局：左边前3个关卡，右边后3个关卡
          const leftColumn = keys.slice(0, 3);
          const rightColumn = keys.slice(3, 6);
          
          html = `
            <div style="display:flex; gap:16px; position:relative;">
              <div style="position:absolute; left:50%; top:0; bottom:0; width:1px; background:var(--line); pointer-events:none;"></div>
              <!-- 左栏 -->
              <div style="flex:1; padding-right:8px;">
                ${leftColumn.length > 0 ? `
                <!-- 左栏标题 -->
                <div class="${getGridClass(isMoonlightEnabled, isFuzhongEnabled, isKingEnabled)}" style="margin-bottom:12px; font-weight:600; color:var(--text); text-align:center;">
                  <div style="padding:4px;">盗印</div>
                  ${isFuzhongEnabled ? '<div style="padding:4px;">负重</div>' : ''}
                  ${isMoonlightEnabled ? '<div style="padding:4px;">月光</div>' : ''}
                  ${isKingEnabled ? '<div style="padding:4px;">王之召唤</div>' : ''}
                </div>
                ` : ''}
                
                ${leftColumn.map((k, index) => {
                  const vSci = parseChinaJiLocal(LEVEL_TARGETS[k]) || LEVEL_TARGETS[k];
                  const vCn = parseChinaJiLocal(LEVEL_TARGETS[k]) ? formatChinaJiLocal(parseChinaJiLocal(LEVEL_TARGETS[k]), getCurrentPrecision()) : LEVEL_TARGETS[k];
                  const vDisp = mode==='sci'? vSci : mode==='cn'? vCn : `${vSci} / ${vCn}`;
                  const a = all[k];
                  const rowId = k.replace(/[^a-zA-Z0-9]/g,'_');
                  const st = levelsState[k] || {};
                  
                  return `
                    <div style="border-bottom:1px solid #eee; padding:12px 0;">
                      <div style="display:flex; justify-content:space-between; align-items:center; gap:8px;">
                        <strong>${k}</strong>
                        <span style="color:#6b7280;">目标分数：${vDisp}</span>
                        <div style="display:flex; gap:8px;">
                          <button type="button" data-confirm5="${k}" class="btn-light">确认手动输入变更</button>
                          <button type="button" data-calc5="${k}">用本关参数计算</button>
                        </div>
                      </div>
                      
                      <div class="${getGridClass(isMoonlightEnabled, isFuzhongEnabled, isKingEnabled)}" style="margin-top:6px;">
                        <div>
                          <!-- 番数输入行 -->
                          <div style="display:flex; align-items:center; gap:8px; margin-bottom:6px;">
                            <span style="font-size:12px;color:#374151; min-width:40px;">番数:</span>
                            <input type="text" id="g5D_${rowId}" name="g5D_${rowId}" value="${getInputDisplayValue(a.actualD, `g5D_${rowId}`)}" class="${getInputClassById(`g5D_${rowId}`)}" style="flex:1; padding:4px;" />
                          </div>
                          <div id="g5D_display_${rowId}" style="font-size:10px; color:#9ca3af; margin:2px 0 6px 44px; min-height:12px;">
                            ${(() => {
                              const formats = formatNumberDisplay((a.actualD||0), 2);
                              let displayText = '';
                              if (formats.raw) displayText += formats.raw;
                              if (formats.raw && formats.sci) displayText += ' / ';
                              if (formats.sci) displayText += formats.sci;
                              if (formats.cn && (a.actualD||0) >= 10000) {
                                displayText += ' / ' + formats.cn;
                              }
                              return displayText;
                            })()}
                          </div>
                          <!-- 按钮和推荐行 -->
                          <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:6px;">
                            <small style="color:#6b7280;">推荐: ${(() => {
                              const val = (a.recD||0);
                              return val >= 10000 ? val.toExponential(2) : val.toFixed(2);
                            })()}</small>
                            <div class="btn-group" style="display:flex; gap:4px;">
                              <button type="button" class="btn-radio tag-d btn-tooltip" data-growth5="d:${k}:普通盗印" data-gtype="普通盗印" data-tooltip="普通盗印">普通盗印</button>
                              <button type="button" class="btn-radio tag-d alt btn-tooltip" data-growth5="d:${k}:天使盗印" data-gtype="天使盗印" data-tooltip="天使盗印">天使盗印</button>
                              <button type="button" class="btn-radio tag-d btn-tooltip" data-growth5="d:${k}:膨胀盗印" data-gtype="膨胀盗印" data-tooltip="膨胀盗印">膨胀盗印</button>
                              <button type="button" class="btn-radio tag-d alt btn-tooltip" data-growth5="d:${k}:膨胀盗印吃卡维" data-gtype="膨胀盗印吃卡维" data-tooltip="膨胀盗印吃卡维">膨胀盗印吃卡维</button>
                            </div>
                            <button type="button" class="btn-tooltip" data-lock5d="${k}" style="font-size:11px; padding:2px 6px;" data-tooltip="${st.lockD ? '取消沿用' : '沿用上一关'}">${st.lockD ? '取消沿用' : '沿用上一关'}</button>
                          </div>
                        </div>
                        ${isFuzhongEnabled ? `
                        <div>
                          <!-- 番数输入行 -->
                          <div style="display:flex; align-items:center; gap:8px; margin-bottom:6px;">
                            <span style="font-size:12px;color:#374151; min-width:40px;">番数:</span>
                            <input type="text" id="g5F_${rowId}" name="g5F_${rowId}" value="${getInputDisplayValue(a.actualF, `g5F_${rowId}`)}" class="${getInputClassById(`g5F_${rowId}`)}" style="flex:1; padding:4px;" />
                          </div>
                          <div id="g5F_display_${rowId}" style="font-size:10px; color:#9ca3af; margin:2px 0 6px 44px; min-height:12px;">
                            ${(() => {
                              const formats = formatNumberDisplay((a.actualF||0), 2);
                              let displayText = '';
                              if (formats.raw) displayText += formats.raw;
                              if (formats.raw && formats.sci) displayText += ' / ';
                              if (formats.sci) displayText += formats.sci;
                              if (formats.cn && (a.actualF||0) >= 10000) {
                                displayText += ' / ' + formats.cn;
                              }
                              return displayText;
                            })()}
                          </div>
                          <!-- 按钮和推荐行 -->
                          <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:6px;">
                            <small style="color:#6b7280;">推荐: ${(() => {
                              const val = (a.recF||0);
                              return val >= 10000 ? val.toExponential(2) : val.toFixed(2);
                            })()}</small>
                            <div class="btn-group" style="display:flex; gap:4px;">
                              <button type="button" class="btn-radio tag-f btn-tooltip" data-growth5="f:${k}:普通负重" data-gtype="普通负重" data-tooltip="普通负重">普通负重</button>
                              <button type="button" class="btn-radio tag-f alt btn-tooltip" data-growth5="f:${k}:天使负重" data-gtype="天使负重" data-tooltip="天使负重">天使负重</button>
                              <button type="button" class="btn-radio tag-f btn-tooltip" data-growth5="f:${k}:膨胀负重" data-gtype="膨胀负重" data-tooltip="膨胀负重">膨胀负重</button>
                            </div>
                            <button type="button" class="btn-tooltip" data-lock5f="${k}" style="font-size:11px; padding:2px 6px;" data-tooltip="${st.lockF ? '取消沿用' : '沿用上一关'}">${st.lockF ? '取消沿用' : '沿用上一关'}</button>
                          </div>
                        </div>
                        ` : ''}
                        ${isMoonlightEnabled ? `
                        <div>
                          <!-- 番数输入行 -->
                          <div style="display:flex; align-items:center; gap:8px; margin-bottom:6px;">
                            <span style="font-size:12px;color:#374151; min-width:40px;">番数:</span>
                            <input type="text" id="g5Y_${rowId}" name="g5Y_${rowId}" value="${getInputDisplayValue(a.actualY, `g5Y_${rowId}`)}" class="${getInputClassById(`g5Y_${rowId}`)}" style="flex:1; padding:4px;" />
                          </div>
                          <div id="g5Y_display_${rowId}" style="font-size:10px; color:#9ca3af; margin:2px 0 6px 44px; min-height:12px;">
                            ${(() => {
                              const formats = formatNumberDisplay((a.actualY||0), 2);
                              let displayText = '';
                              if (formats.raw) displayText += formats.raw;
                              if (formats.raw && formats.sci) displayText += ' / ';
                              if (formats.sci) displayText += formats.sci;
                              if (formats.cn && (a.actualY||0) >= 10000) {
                                displayText += ' / ' + formats.cn;
                              }
                              return displayText;
                            })()}
                          </div>
                          <!-- 按钮和推荐行 -->
                          <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:6px;">
                            <small style="color:#6b7280;">推荐: ${(() => {
                              const val = (a.recY||0);
                              return val >= 10000 ? val.toExponential(2) : val.toFixed(2);
                            })()}</small>
                            <div class="btn-group" style="display:flex; gap:4px;">
                              <button type="button" class="btn-radio tag-y btn-tooltip" data-growth5="y:${k}:普通月光" data-gtype="普通月光" data-tooltip="普通月光">普通月光</button>
                              <button type="button" class="btn-radio tag-y alt btn-tooltip" data-growth5="y:${k}:天使月光" data-gtype="天使月光" data-tooltip="天使月光">天使月光</button>
                              <button type="button" class="btn-radio tag-y btn-tooltip" data-growth5="y:${k}:膨胀月光" data-gtype="膨胀月光" data-tooltip="膨胀月光">膨胀月光</button>
                            </div>
                            <button type="button" class="btn-tooltip" data-lock5y="${k}" style="font-size:11px; padding:2px 6px;" data-tooltip="${st.lockY ? '取消沿用' : '沿用上一关'}">${st.lockY ? '取消沿用' : '沿用上一关'}</button>
                          </div>
                        </div>
                        ` : ''}
                        ${isKingEnabled ? `
                        <div>
                          <!-- 王之召唤番数和胡牌在同一行 -->
                          <div style="display:flex; gap:8px; margin-bottom:6px;">
                            <div style="flex:1;">
                              <div style="display:flex; align-items:center; gap:4px;">
                                <span style="font-size:12px;color:#374151; min-width:30px;">番数:</span>
                                <input type="text" id="g5K_${rowId}" name="g5K_${rowId}" value="${getInputDisplayValue(a.actualK, `g5K_${rowId}`)}" class="${getInputClassById(`g5K_${rowId}`)}" style="flex:1; padding:4px;" />
                              </div>
                              <div id="g5K_display_${rowId}" style="font-size:10px; color:#9ca3af; margin:2px 0 0 34px; min-height:12px;">
                                ${(() => {
                                  const formats = formatNumberDisplay((a.actualK||0), 2);
                                  let displayText = '';
                                  if (formats.raw) displayText += formats.raw;
                                  if (formats.raw && formats.sci) displayText += ' / ';
                                  if (formats.sci) displayText += formats.sci;
                                  if (formats.cn && (a.actualK||0) >= 10000) {
                                    displayText += ' / ' + formats.cn;
                                  }
                                  return displayText;
                                })()}
                              </div>
                            </div>
                            <div style="flex:1;">
                              <div style="display:flex; align-items:center; gap:4px;">
                                <span style="font-size:12px;color:#374151; min-width:30px;">胡牌:</span>
                                <input type="number" id="g5KH_${rowId}" name="g5KH_${rowId}" value="${getInputDisplayValue(a.actualKH, `g5KH_${rowId}`)}" class="${getInputClassById(`g5KH_${rowId}`)}" min="1" style="flex:1; padding:4px;" />
                              </div>
                              <div id="g5KH_display_${rowId}" style="font-size:10px; color:#9ca3af; margin:2px 0 0 34px; min-height:12px;">
                                <!-- 胡牌次数不需要显示大数字格式，因为它是整数 -->
                              </div>
                            </div>
                          </div>
                          <!-- 按钮和推荐行 -->
                          <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:6px;">
                            <small style="color:#6b7280;">推荐: ${(() => {
                              const val = (a.recK||0);
                              return val >= 10000 ? val.toExponential(2) : val.toFixed(2);
                            })()}</small>
                            <button type="button" class="btn-tooltip" data-lock5k="${k}" style="font-size:11px; padding:2px 6px;" data-tooltip="${st.lockK ? '取消沿用' : '沿用上一关'}">${st.lockK ? '取消沿用' : '沿用上一关'}</button>
                          </div>
                        </div>
                        ` : ''}
                      </div>
                    </div>
                  `;
                }).join('')}
              </div>
              
              <!-- 右栏 -->
              <div style="flex:1; padding-left:8px;">
                ${rightColumn.length > 0 ? `
                <!-- 右栏标题 -->
                <div class="${getGridClass(isMoonlightEnabled, isFuzhongEnabled, isKingEnabled)}" style="margin-bottom:12px; font-weight:600; color:var(--text); text-align:center;">
                  <div style="padding:4px;">盗印</div>
                  ${isFuzhongEnabled ? '<div style="padding:4px;">负重</div>' : ''}
                  ${isMoonlightEnabled ? '<div style="padding:4px;">月光</div>' : ''}
                  ${isKingEnabled ? '<div style="padding:4px;">王之召唤</div>' : ''}
                </div>
                ` : ''}
                
                ${rightColumn.map((k, index) => {
                  const vSci = parseChinaJiLocal(LEVEL_TARGETS[k]) || LEVEL_TARGETS[k];
                  const vCn = parseChinaJiLocal(LEVEL_TARGETS[k]) ? formatChinaJiLocal(parseChinaJiLocal(LEVEL_TARGETS[k]), getCurrentPrecision()) : LEVEL_TARGETS[k];
                  const vDisp = mode==='sci'? vSci : mode==='cn'? vCn : `${vSci} / ${vCn}`;
                  const a = all[k];
                  const rowId = k.replace(/[^a-zA-Z0-9]/g,'_');
                  const st = levelsState[k] || {};
                  
                  return `
                    <div style="border-bottom:1px solid #eee; padding:12px 0;">
                      <div style="display:flex; justify-content:space-between; align-items:center; gap:8px;">
                        <strong>${k}</strong>
                        <span style="color:#6b7280;">目标分数：${vDisp}</span>
                        <div style="display:flex; gap:8px;">
                          <button type="button" data-confirm5="${k}" class="btn-light">确认手动输入变更</button>
                          <button type="button" data-calc5="${k}">用本关参数计算</button>
                        </div>
                      </div>
                      
                      <div class="${getGridClass(isMoonlightEnabled, isFuzhongEnabled, isKingEnabled)}" style="margin-top:6px;">
                        <div>
                          <!-- 番数输入行 -->
                          <div style="display:flex; align-items:center; gap:8px; margin-bottom:6px;">
                            <span style="font-size:12px;color:#374151; min-width:40px;">番数:</span>
                            <input type="text" id="g5D_${rowId}" name="g5D_${rowId}" value="${getInputDisplayValue(a.actualD, `g5D_${rowId}`)}" class="${getInputClassById(`g5D_${rowId}`)}" style="flex:1; padding:4px;" />
                          </div>
                          <div id="g5D_display_${rowId}" style="font-size:10px; color:#9ca3af; margin:2px 0 6px 44px; min-height:12px;">
                            ${(() => {
                              const formats = formatNumberDisplay((a.actualD||0), 2);
                              let displayText = '';
                              if (formats.raw) displayText += formats.raw;
                              if (formats.raw && formats.sci) displayText += ' / ';
                              if (formats.sci) displayText += formats.sci;
                              if (formats.cn && (a.actualD||0) >= 10000) {
                                displayText += ' / ' + formats.cn;
                              }
                              return displayText;
                            })()}
                          </div>
                          <!-- 按钮和推荐行 -->
                          <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:6px;">
                            <small style="color:#6b7280;">推荐: ${(() => {
                              const val = (a.recD||0);
                              return val >= 10000 ? val.toExponential(2) : val.toFixed(2);
                            })()}</small>
                            <div class="btn-group" style="display:flex; gap:4px;">
                              <button type="button" class="btn-radio tag-d btn-tooltip" data-growth5="d:${k}:普通盗印" data-gtype="普通盗印" data-tooltip="普通盗印">普通盗印</button>
                              <button type="button" class="btn-radio tag-d alt btn-tooltip" data-growth5="d:${k}:天使盗印" data-gtype="天使盗印" data-tooltip="天使盗印">天使盗印</button>
                              <button type="button" class="btn-radio tag-d btn-tooltip" data-growth5="d:${k}:膨胀盗印" data-gtype="膨胀盗印" data-tooltip="膨胀盗印">膨胀盗印</button>
                              <button type="button" class="btn-radio tag-d alt btn-tooltip" data-growth5="d:${k}:膨胀盗印吃卡维" data-gtype="膨胀盗印吃卡维" data-tooltip="膨胀盗印吃卡维">膨胀盗印吃卡维</button>
                            </div>
                            <button type="button" class="btn-tooltip" data-lock5d="${k}" style="font-size:11px; padding:2px 6px;" data-tooltip="${st.lockD ? '取消沿用' : '沿用上一关'}">${st.lockD ? '取消沿用' : '沿用上一关'}</button>
                          </div>
                        </div>
                        ${isFuzhongEnabled ? `
                        <div>
                          <!-- 番数输入行 -->
                          <div style="display:flex; align-items:center; gap:8px; margin-bottom:6px;">
                            <span style="font-size:12px;color:#374151; min-width:40px;">番数:</span>
                            <input type="text" id="g5F_${rowId}" name="g5F_${rowId}" value="${getInputDisplayValue(a.actualF, `g5F_${rowId}`)}" class="${getInputClassById(`g5F_${rowId}`)}" style="flex:1; padding:4px;" />
                          </div>
                          <div id="g5F_display_${rowId}" style="font-size:10px; color:#9ca3af; margin:2px 0 6px 44px; min-height:12px;">
                            ${(() => {
                              const formats = formatNumberDisplay((a.actualF||0), 2);
                              let displayText = '';
                              if (formats.raw) displayText += formats.raw;
                              if (formats.raw && formats.sci) displayText += ' / ';
                              if (formats.sci) displayText += formats.sci;
                              if (formats.cn && (a.actualF||0) >= 10000) {
                                displayText += ' / ' + formats.cn;
                              }
                              return displayText;
                            })()}
                          </div>
                          <!-- 按钮和推荐行 -->
                          <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:6px;">
                            <small style="color:#6b7280;">推荐: ${(() => {
                              const val = (a.recF||0);
                              return val >= 10000 ? val.toExponential(2) : val.toFixed(2);
                            })()}</small>
                            <div class="btn-group" style="display:flex; gap:4px;">
                              <button type="button" class="btn-radio tag-f btn-tooltip" data-growth5="f:${k}:普通负重" data-gtype="普通负重" data-tooltip="普通负重">普通负重</button>
                              <button type="button" class="btn-radio tag-f alt btn-tooltip" data-growth5="f:${k}:天使负重" data-gtype="天使负重" data-tooltip="天使负重">天使负重</button>
                              <button type="button" class="btn-radio tag-f btn-tooltip" data-growth5="f:${k}:膨胀负重" data-gtype="膨胀负重" data-tooltip="膨胀负重">膨胀负重</button>
                            </div>
                            <button type="button" class="btn-tooltip" data-lock5f="${k}" style="font-size:11px; padding:2px 6px;" data-tooltip="${st.lockF ? '取消沿用' : '沿用上一关'}">${st.lockF ? '取消沿用' : '沿用上一关'}</button>
                          </div>
                        </div>
                        ` : ''}
                        ${isMoonlightEnabled ? `
                        <div>
                          <!-- 番数输入行 -->
                          <div style="display:flex; align-items:center; gap:8px; margin-bottom:6px;">
                            <span style="font-size:12px;color:#374151; min-width:40px;">番数:</span>
                            <input type="text" id="g5Y_${rowId}" name="g5Y_${rowId}" value="${getInputDisplayValue(a.actualY, `g5Y_${rowId}`)}" class="${getInputClassById(`g5Y_${rowId}`)}" style="flex:1; padding:4px;" />
                          </div>
                          <div id="g5Y_display_${rowId}" style="font-size:10px; color:#9ca3af; margin:2px 0 6px 44px; min-height:12px;">
                            ${(() => {
                              const formats = formatNumberDisplay((a.actualY||0), 2);
                              let displayText = '';
                              if (formats.raw) displayText += formats.raw;
                              if (formats.raw && formats.sci) displayText += ' / ';
                              if (formats.sci) displayText += formats.sci;
                              if (formats.cn && (a.actualY||0) >= 10000) {
                                displayText += ' / ' + formats.cn;
                              }
                              return displayText;
                            })()}
                          </div>
                          <!-- 按钮和推荐行 -->
                          <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:6px;">
                            <small style="color:#6b7280;">推荐: ${(() => {
                              const val = (a.recY||0);
                              return val >= 10000 ? val.toExponential(2) : val.toFixed(2);
                            })()}</small>
                            <div class="btn-group" style="display:flex; gap:4px;">
                              <button type="button" class="btn-radio tag-y btn-tooltip" data-growth5="y:${k}:普通月光" data-gtype="普通月光" data-tooltip="普通月光">普通月光</button>
                              <button type="button" class="btn-radio tag-y alt btn-tooltip" data-growth5="y:${k}:天使月光" data-gtype="天使月光" data-tooltip="天使月光">天使月光</button>
                              <button type="button" class="btn-radio tag-y btn-tooltip" data-growth5="y:${k}:膨胀月光" data-gtype="膨胀月光" data-tooltip="膨胀月光">膨胀月光</button>
                            </div>
                            <button type="button" class="btn-tooltip" data-lock5y="${k}" style="font-size:11px; padding:2px 6px;" data-tooltip="${st.lockY ? '取消沿用' : '沿用上一关'}">${st.lockY ? '取消沿用' : '沿用上一关'}</button>
                          </div>
                        </div>
                        ` : ''}
                        ${isKingEnabled ? `
                        <div>
                          <!-- 王之召唤番数和胡牌在同一行 -->
                          <div style="display:flex; gap:8px; margin-bottom:6px;">
                            <div style="flex:1;">
                              <div style="display:flex; align-items:center; gap:4px;">
                                <span style="font-size:12px;color:#374151; min-width:30px;">番数:</span>
                                <input type="text" id="g5K_${rowId}" name="g5K_${rowId}" value="${getInputDisplayValue(a.actualK, `g5K_${rowId}`)}" class="${getInputClassById(`g5K_${rowId}`)}" style="flex:1; padding:4px;" />
                              </div>
                              <div id="g5K_display_${rowId}" style="font-size:10px; color:#9ca3af; margin:2px 0 0 34px; min-height:12px;">
                                ${(() => {
                                  const formats = formatNumberDisplay((a.actualK||0), 2);
                                  let displayText = '';
                                  if (formats.raw) displayText += formats.raw;
                                  if (formats.raw && formats.sci) displayText += ' / ';
                                  if (formats.sci) displayText += formats.sci;
                                  if (formats.cn && (a.actualK||0) >= 10000) {
                                    displayText += ' / ' + formats.cn;
                                  }
                                  return displayText;
                                })()}
                              </div>
                            </div>
                            <div style="flex:1;">
                              <div style="display:flex; align-items:center; gap:4px;">
                                <span style="font-size:12px;color:#374151; min-width:30px;">胡牌:</span>
                                <input type="number" id="g5KH_${rowId}" name="g5KH_${rowId}" value="${getInputDisplayValue(a.actualKH, `g5KH_${rowId}`)}" class="${getInputClassById(`g5KH_${rowId}`)}" min="1" style="flex:1; padding:4px;" />
                              </div>
                              <div id="g5KH_display_${rowId}" style="font-size:10px; color:#9ca3af; margin:2px 0 0 34px; min-height:12px;">
                                <!-- 胡牌次数不需要显示大数字格式，因为它是整数 -->
                              </div>
                            </div>
                          </div>
                          <!-- 按钮和推荐行 -->
                          <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:6px;">
                            <small style="color:#6b7280;">推荐: ${(() => {
                              const val = (a.recK||0);
                              return val >= 10000 ? val.toExponential(2) : val.toFixed(2);
                            })()}</small>
                            <button type="button" class="btn-tooltip" data-lock5k="${k}" style="font-size:11px; padding:2px 6px;" data-tooltip="${st.lockK ? '取消沿用' : '沿用上一关'}">${st.lockK ? '取消沿用' : '沿用上一关'}</button>
                          </div>
                        </div>
                        ` : ''}
                      </div>
                    </div>
                  `;
                }).join('')}
              </div>
            </div>
          `;
        }
        
        $('levelList5').innerHTML = html;
        
        // 绑定事件（每次渲染后重新绑定）- 限定在 levelList5 容器内
        const container5 = document.getElementById('levelList5');
        
        // 更新按钮选中状态的函数（在 renderPage5 内部定义，供内部使用）
        const updateButtonStates = () => {
          // 遍历所有关卡的增长类型按钮
          keyOrder.forEach(level => {
            // 盗印按钮
            ['普通盗印', '天使盗印', '膨胀盗印', '膨胀盗印吃卡维'].forEach(type => {
              const btn = container5.querySelector(`button[data-gtype="${type}"][data-growth5^="d:${level}:"]`);
              if (btn) {
                const currentType = resolveTypeAtIndex('d', keyOrder.indexOf(level));
                btn.classList.toggle('selected', currentType === type);
              }
            });
            
            // 负重按钮
            ['普通负重', '天使负重', '膨胀负重'].forEach(type => {
              const btn = container5.querySelector(`button[data-gtype="${type}"][data-growth5^="f:${level}:"]`);
              if (btn) {
                const currentType = resolveTypeAtIndex('f', keyOrder.indexOf(level));
                btn.classList.toggle('selected', currentType === type);
              }
            });
            
            // 月光按钮
            ['普通月光', '天使月光', '膨胀月光'].forEach(type => {
              const btn = container5.querySelector(`button[data-gtype="${type}"][data-growth5^="y:${level}:"]`);
              if (btn) {
                const currentType = resolveTypeAtIndex('y', keyOrder.indexOf(level));
                btn.classList.toggle('selected', currentType === type);
              }
            });
          });
        };

        // 增长类型按钮
        container5.querySelectorAll('button[data-growth5]').forEach(btn => {
          btn.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            console.log('Growth button clicked:', btn.getAttribute('data-growth5'));
            
            const dataValue = btn.getAttribute('data-growth5');
            const parts = dataValue.split(':');
            if (parts.length < 3) return;
            const kind = parts[0];
            const key = parts[1];
            const type = parts[2];
            
            console.log('Applying type:', type, 'from level:', key);
            
            const startIdx = keyOrder.indexOf(key);
            if (startIdx === -1) return;
            
            // 从该关起应用到所有后续关卡
            for (let i=startIdx; i<keyOrder.length; i++){
              const k2 = keyOrder[i];
              ivData[k2] = ivData[k2] || {};
              if (kind === 'd') ivData[k2].dType = type;
              if (kind === 'f') ivData[k2].fType = type;
              if (kind === 'y') ivData[k2].yType = type;
            }
            console.log('ivData updated, sample:', {
              '1-1': ivData['1-1'],
              '1-2': ivData['1-2'],
              '1-3': ivData['1-3']
            });
            
            // 更新按钮选中状态
            updateButtonStates();
            
            // 检查是否影响当前印章计数关卡
            if (window.selectedSealLevel && kind === 'd') {
              const selectedLevelIdx = keyOrder.indexOf(window.selectedSealLevel);
              if (selectedLevelIdx >= startIdx) {
                // 影响当前选择的关卡，显示提示
                showSealCounterNotification();
              }
            }
            
            renderPage5();
          });
        });
        
        // 沿用上一关按钮 - 参考 renderPage 的实现
        container5.querySelectorAll('button[data-lock5d]').forEach(btn => {
          btn.addEventListener('click', (e) => {
            e.preventDefault();
            const k = btn.getAttribute('data-lock5d');
            console.log('Lock D clicked for:', k);
            // 切换 lockD 状态（与 renderPage 一致）
            levelsState[k] = levelsState[k] || {};
            levelsState[k].lockD = !levelsState[k].lockD;
            console.log('lockD state:', levelsState[k].lockD);
            renderPage5();
          });
        });
        container5.querySelectorAll('button[data-lock5f]').forEach(btn => {
          btn.addEventListener('click', (e) => {
            e.preventDefault();
            const k = btn.getAttribute('data-lock5f');
            levelsState[k] = levelsState[k] || {};
            levelsState[k].lockF = !levelsState[k].lockF;
            renderPage5();
          });
        });
        container5.querySelectorAll('button[data-lock5y]').forEach(btn => {
          btn.addEventListener('click', (e) => {
            e.preventDefault();
            const k = btn.getAttribute('data-lock5y');
            levelsState[k] = levelsState[k] || {};
            levelsState[k].lockY = !levelsState[k].lockY;
            renderPage5();
          });
        });
        container5.querySelectorAll('button[data-lock5k]').forEach(btn => {
          btn.addEventListener('click', (e) => {
            e.preventDefault();
            const k = btn.getAttribute('data-lock5k');
            levelsState[k] = levelsState[k] || {};
            levelsState[k].lockK = !levelsState[k].lockK;
            renderPage5();
          });
        });
        
        // 用本关参数计算按钮
        container5.querySelectorAll('button[data-calc5]').forEach(btn => {
          btn.addEventListener('click', async (e) => {
            e.preventDefault();
            const k = btn.getAttribute('data-calc5');
            const a = all[k];
            
            // 修复：同步设置关卡选择器和目标分数
            $('levelSelect').value = k;
            $('targetScore').value = LEVEL_TARGETS[k];
            
            $('daoyin').value = `${(a.actualD||0).toFixed(6)}`;
            $('fuzhong').value = `${(a.actualF||0).toFixed(6)}`;
            $('yueguang').value = `${(a.actualY||0).toFixed(6)}`;
            
            // 设置王之召唤参数（如果王之召唤开启）
            const kingEnabled = document.getElementById('kingEnabled');
            if (kingEnabled && kingEnabled.checked) {
              // 王之召唤触发次数保持当前设置，不需要从关卡数据中获取
              // 因为触发次数是全局设置，不是每个关卡单独的
            }
            
            // 同步刷新右下角格式显示
            updateStampDisplay();
            const unlockD = $('unlockD').value;
            const unlockF = $('unlockF').value;
            const unlockY = $('unlockY').value;
            const kIdx = keyOrder.indexOf(k);
            const idxD = keyOrder.indexOf(unlockD);
            const idxF = keyOrder.indexOf(unlockF);
            const idxY = keyOrder.indexOf(unlockY);
            $('trigD').value = kIdx >= idxD && idxD>=0 ? $('trigD').value : '0';
            $('trigF').value = kIdx >= idxF && idxF>=0 ? $('trigF').value : '0';
            $('trigY').value = kIdx >= idxY && idxY>=0 ? $('trigY').value : '0';
            await computeWithForm();
            
            // 自动弹出计算结果模态框
            const resultToggle = document.getElementById('resultToggle');
            const floatingResult = document.getElementById('floatingResult');
            if (resultToggle && floatingResult) {
              resultToggle.checked = true;
              floatingResult.style.display = 'block';
            }
            // 更新预测
            updatePrediction();
          });
        });
        
        // 为番数输入框添加实时显示大数字系统的事件监听器
        container5.querySelectorAll('input[id^="g5D_"], input[id^="g5F_"], input[id^="g5Y_"], input[id^="g5K_"], input[id^="g5KH_"]').forEach(input => {
          input.addEventListener('input', function() {
            const value = this.value.trim();
            const displayId = this.id.replace(/^g5([DFYKH]?)_/, 'g5$1_display_');
            const displayEl = document.getElementById(displayId);
            
            if (displayEl) {
              if (!value) {
                displayEl.textContent = '';
                return;
              }
              
              // 尝试解析输入值
              let num = parseFloat(value);
              if (isNaN(num)) {
                const sciStr = parseChinaJiLocal(value);
                if (sciStr) {
                  num = parseFloat(sciStr);
                }
              }
              
              if (!isNaN(num)) {
                const formats = formatNumberDisplay(num, 2);
                let displayText = '';
                
                if (formats.raw) displayText += formats.raw;
                if (formats.raw && formats.sci) displayText += ' / ';
                if (formats.sci) displayText += formats.sci;
                if (formats.cn && num >= 10000) {
                  displayText += ' / ' + formats.cn;
                }
                
                displayEl.textContent = displayText;
              } else {
                displayEl.textContent = '';
              }
            }
            
            // 注意：不在这里保存到levelsState，只在确认按钮点击时保存
            // 这样可以避免输入过程中频繁更新状态，同时保持与backversion一致的行为
            
            // 但是需要保持输入框的原始值，避免在重新渲染时丢失用户的中文单位输入
            // 记录本行未保存修改，并高亮该输入框
            const info = parseInputId(this.id);
            setPending(info.rowId, info.field, this.value);
            this.classList.add('modified-input');
          });
        });

        // 在输入结束（失焦）时再统一重渲染，更新推荐值/按钮状态，避免打字过程中焦点丢失
        container5.querySelectorAll('input[id^="g5D_"], input[id^="g5F_"], input[id^="g5Y_"], input[id^="g5K_"], input[id^="g5KH_"]').forEach(input => {
          input.addEventListener('blur', function() {
            if (suppressRenderOnBlur) return;
            // 异步执行，确保优先处理点击事件
            setTimeout(() => {
              if (suppressRenderOnBlur) return;
              renderPage5();
            }, 0);
          });
        });
        
        // 确认手动输入变更按钮
        container5.querySelectorAll('button[data-confirm5]').forEach(btn => {
          // 在按下时先标记，避免输入框 blur 的重渲染打断第一次点击
          btn.addEventListener('pointerdown', () => { suppressRenderOnBlur = true; });
          btn.addEventListener('click', async (e) => {
            e.preventDefault();
            const k = btn.getAttribute('data-confirm5');
            const rowId = k.replace(/[^a-zA-Z0-9]/g,'_');
            
            // 获取用户输入的番数值（优先使用 pendingEdits 暂存，确保一次点击提交整行修改）
            const inputD = document.getElementById(`g5D_${rowId}`);
            const inputF = document.getElementById(`g5F_${rowId}`);
            const inputY = document.getElementById(`g5Y_${rowId}`);
            const inputK = document.getElementById(`g5K_${rowId}`);
            const inputKH = document.getElementById(`g5KH_${rowId}`);
            
            // 检查必需的输入框
            if (!inputD) return;
            
            // 检查负重输入框是否存在（如果负重开启）
            const fuzhongToggle = document.getElementById('fuzhongToggle');
            if (fuzhongToggle && fuzhongToggle.checked) {
              if (!inputF) {
                console.warn('负重开启但输入框不存在:', { inputF });
                return;
              }
            }
            
            // 检查月光输入框是否存在（如果月光开启）
            const moonlightToggle = document.getElementById('moonlightToggle');
            if (moonlightToggle && moonlightToggle.checked) {
              if (!inputY) {
                console.warn('月光开启但输入框不存在:', { inputY });
                return;
              }
            }
            
            // 检查王之召唤输入框是否存在（如果王之召唤开启）
            const kingEnabled = document.getElementById('kingEnabled');
            if (kingEnabled && kingEnabled.checked) {
              if (!inputK || !inputKH) {
                console.warn('王之召唤开启但输入框不存在:', { inputK, inputKH });
                return;
              }
            }
            
            // 解析输入值（支持大数字系统）
            const parseInput = (value) => {
              const trimmed = value.trim();
              if (!trimmed) return null;
              
              // 先尝试解析大数字系统（包括小数部分）
              const sciStr = parseChinaJiLocal(trimmed);
              if (sciStr) {
                const num = parseFloat(sciStr);
                return isNaN(num) ? null : num;
              }
              
              // 如果解析失败，尝试直接解析数字
              const num = parseFloat(trimmed);
              return isNaN(num) ? null : num;
            };
            
            const pend = pendingEditsByRowId[rowId] || {};
            const valD = pend.D != null ? String(pend.D) : (inputD ? inputD.value : '');
            const valF = pend.F != null ? String(pend.F) : (inputF ? inputF.value : '');
            const valY = pend.Y != null ? String(pend.Y) : (inputY ? inputY.value : '');
            const valK = pend.K != null ? String(pend.K) : (inputK ? inputK.value : '');
            const valKH = pend.KH != null ? String(pend.KH) : (inputKH ? inputKH.value : '');

            const newD = parseInput(valD);
            const newF = inputF ? parseInput(valF) : null;
            const newY = inputY ? parseInput(valY) : null;
            const newK = inputK ? parseInput(valK) : null;
            const newKH = inputKH ? (parseInt(valKH) || 1) : null;
            
            console.log('Confirming manual input for:', k, { newD, newF, newY, newK, newKH });
            
            // 更新 levelsState 中的手动输入值（保存解析后的数值字符串），不受开关显示影响
            levelsState[k] = levelsState[k] || {};
            if (newD !== null) levelsState[k].manuD = newD.toString();
            if (newF !== null) levelsState[k].manuF = newF.toString();
            if (newY !== null) levelsState[k].manuY = newY.toString();
            if (newK !== null) levelsState[k].manuK = newK.toString();
            if (newKH !== null) levelsState[k].manuKH = newKH.toString();
            
            // 联动更新解锁关：若本关手动输入 >0，则把对应解锁选择器更新为当前关
            const currentIndex = keyOrder.indexOf(k);
            const updateUnlock = (selId, enabled, val) => {
              const sel = $(selId);
              if (!sel) return;
              if (enabled && val != null && val > 0) {
                const idx = keyOrder.indexOf(sel.value);
                if (idx < 0 || currentIndex < idx) sel.value = k;
              }
            };
            updateUnlock('unlockD', true, newD);
            updateUnlock('unlockF', (fuzhongToggle && fuzhongToggle.checked), newF);
            updateUnlock('unlockY', (moonlightToggle && moonlightToggle.checked), newY);
            // 王之召唤的级联起点由 computeRecommendedAll 的 manualKStartIndex/Value 自动处理
            
            // 确认较早行时，清除之后所有关卡的手动覆盖，确保重新按链式推荐生效
            if (currentIndex >= 0) {
              for (let i = currentIndex + 1; i < keyOrder.length; i++) {
                const nk = keyOrder[i];
                if (levelsState[nk]) {
                  delete levelsState[nk].manuD;
                  delete levelsState[nk].manuF;
                  delete levelsState[nk].manuY;
                  delete levelsState[nk].manuK;
                  delete levelsState[nk].manuKH;
                }
              }
            }

            // 清空本行 pending 高亮
            clearPendingRow(rowId);
            
            // 刷新页面显示（唯一刷新点），并解除抑制标记
            renderPage5();
            suppressRenderOnBlur = false;
          });
        });
        
        // 在事件绑定完成后更新按钮状态
        updateButtonStates();
        
        $('pageInfo5').textContent = `第 ${page5+1} 页 / 共 ${Math.ceil(keyOrder.length/PAGE5)} 页`;
        
        // 更新页面选择器
        const pageInput5 = document.getElementById('pageInput5');
        if (pageInput5) {
          pageInput5.max = Math.ceil(keyOrder.length/PAGE5);
          pageInput5.value = page5 + 1;
        }
      }
      
      document.getElementById('prev5').addEventListener('click', ()=>{ if (page5>0){ page5--; renderPage5(); }});
      document.getElementById('next5').addEventListener('click', ()=>{ if ((page5+1)*PAGE5 < keyOrder.length){ page5++; renderPage5(); }});
      
      // 页面选择器事件监听器
      document.getElementById('goToPage5').addEventListener('click', () => {
        const pageInput = document.getElementById('pageInput5');
        const targetPage = parseInt(pageInput.value);
        
        // 由于输入框已经限制了范围，这里不需要额外的验证
        page5 = targetPage - 1; // 转换为0基索引
        renderPage5();
      });
      
      // 页面输入框回车事件
      document.getElementById('pageInput5').addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
          document.getElementById('goToPage5').click();
        }
      });
      
      // 布局切换按钮事件监听器
      document.getElementById('layoutSwitch').addEventListener('click', () => {
        currentLayout = 'single';
        document.getElementById('layoutSwitch').classList.add('active');
        document.getElementById('layoutSwitch2').classList.remove('active');
        renderPage5();
      });
      
      document.getElementById('layoutSwitch2').addEventListener('click', () => {
        currentLayout = 'two-column';
        document.getElementById('layoutSwitch2').classList.add('active');
        document.getElementById('layoutSwitch').classList.remove('active');
        renderPage5();
      });
      
      // 初始化渲染每页6项列表（放在定义与监听之后，避免引用顺序错误）
      renderPage5();
  // 初始化历史列表
  populateHistorySelect();
  // 绑定新流程控件
  const saveBtn = document.getElementById('saveCurrentBtn');
  if (saveBtn) saveBtn.addEventListener('click', ()=>{ const f=document.getElementById('saveFlow'); if (f) f.style.display='flex'; });
  const confirmSaveBtn = document.getElementById('confirmSaveBtn');
  if (confirmSaveBtn) confirmSaveBtn.addEventListener('click', ()=>{ saveCurrentLevelData(); const f=document.getElementById('saveFlow'); const i=document.getElementById('historyName'); if(f) f.style.display='none'; if(i) i.value=''; });
  const cancelSaveBtn = document.getElementById('cancelSaveBtn');
  if (cancelSaveBtn) cancelSaveBtn.addEventListener('click', ()=>{ const f=document.getElementById('saveFlow'); const i=document.getElementById('historyName'); if(f) f.style.display='none'; if(i) i.value=''; });
  const delBtn = document.getElementById('dropdownDeleteBtn');
  if (delBtn) delBtn.addEventListener('click', deleteHistory);
  const historySelect = document.getElementById('historySelect');
  if (historySelect) historySelect.addEventListener('change', ()=>{ if(historySelect.value) loadHistoryLevelData(); });
      
      
      // 未来关卡预测功能
      function predictFutureLevels() {
        try {
          const all = computeRecommendedAll();
          const currentLevel = $('levelSelect')?.value;
          const currentIdx = currentLevel ? keyOrder.indexOf(currentLevel) : -1;
          
          // 如果找不到当前关卡，不执行预测
          if (currentIdx === -1) {
            const currentEl = document.getElementById('currentPrediction');
            const maxEl = document.getElementById('maxPrediction');
            if (currentEl) currentEl.innerHTML = '<span style="color: var(--muted);">请先选择关卡</span>';
            if (maxEl) maxEl.innerHTML = '<span style="color: var(--muted);">请先选择关卡</span>';
            return;
          }
          
          // 获取当前触发次数
          const currentTrigD = Number(($('trigD')?.value) || '0');
          const currentTrigF = Number(($('trigF')?.value) || '0');
          const currentTrigY = Number(($('trigY')?.value) || '0');
          
          // 获取最大触发次数
          const maxTrigD = Number(($('maxTrigD')?.value) || '0');
          const maxTrigF = Number(($('maxTrigF')?.value) || '0');
          const maxTrigY = Number(($('maxTrigY')?.value) || '0');
        
        // 预测函数
        const predict = (trigD, trigF, trigY, label) => {
          let result = '';
          let found = false;
          
          for (let i = currentIdx + 1; i < keyOrder.length; i++) {
            const level = keyOrder[i];
            const targetScore = parseFloat(parseChinaJiLocal(LEVEL_TARGETS[level]) || LEVEL_TARGETS[level]);
            const levelData = all[level];
            
            if (!levelData) continue;
            
            // 计算总分数（使用指定的触发次数）
            // 如果触发次数为0或番数为0，则忽略该护符，否则使用番数的触发次方
            const daoyinMultiplier = (trigD === 0 || levelData.actualD === 0) ? 1 : Math.pow(levelData.actualD, trigD);
            const fuzhongMultiplier = (trigF === 0 || levelData.actualF === 0) ? 1 : Math.pow(levelData.actualF, trigF);
            const yueguangMultiplier = (trigY === 0 || levelData.actualY === 0) ? 1 : Math.pow(levelData.actualY, trigY);
            
            // 王之召唤连乘计算：使用统一的计算函数（当王之召唤番数为0时忽略）
            let kingMultiplier = 1;
            if (levelData.actualK && levelData.actualKH && levelData.actualK !== 0) {
              const currentKingFan = levelData.actualK; // 当前关卡的王之召唤番数
              const winCountFromSettings = parseFloat($('finalMulInput').value) || 1; // 数值设置中的胡牌番数
              const triggerCount = parseInt($('trigK').value) || 4; // 王之召唤实际触发次数
              
              // 使用统一的王之召唤乘数计算函数
              kingMultiplier = calculateKingCallMultiplier(currentKingFan, triggerCount, winCountFromSettings);
            }
            
            const totalScore = levelData.baseScore * levelData.finalMultiplier * 
                             daoyinMultiplier * 
                             fuzhongMultiplier * 
                             yueguangMultiplier * 
                             kingMultiplier;
            
            // 王之召唤调试信息（显示在控制台）
            /*
            if (levelData.actualK && levelData.actualKH) {
              const currentKingFan = levelData.actualK;
              const winCountFromSettings = parseFloat($('finalMulInput').value) || 1;
              const triggerCount = parseInt($('trigK').value) || 4;
              
              // console.log(`🎯 王之召唤调试 - ${level}:`);
              // console.log(`   当前关卡王之召唤番数: ${currentKingFan}`);
              // console.log(`   王之召唤实际触发次数: ${triggerCount}`);
              // console.log(`   数值设置中的胡牌番数: ${winCountFromSettings}`);
              // console.log(`   王之召唤乘数: ${kingMultiplier}`);
              console.log(`   总分数: ${totalScore}`);
              console.log('---');
            }
            */
            
            if (totalScore > targetScore) {
              const ratio = totalScore / targetScore;
              const targetDisp = formatChinaJiLocal(targetScore.toString(), 2);
              const scoreDisp = formatChinaJiLocal(totalScore.toString(), 2);
              
              result = `<span style="color: var(--ok); font-weight: bold;">${level}</span> - 目标: ${targetDisp}, 预计得分: ${scoreDisp} (${ratio.toFixed(1)}倍)`;
              found = true;
              break;
            }
          }
          
          if (!found) {
            result = '<span style="color: var(--muted);">无法在当前配置下超越目标分</span>';
          }
          
          return result;
        };
        
          // 更新预测显示
          const currentEl = document.getElementById('currentPrediction');
          const maxEl = document.getElementById('maxPrediction');
          
          if (currentEl) {
            currentEl.innerHTML = predict(currentTrigD, currentTrigF, currentTrigY, '当前配置');
          }
          
          if (maxEl) {
            maxEl.innerHTML = predict(maxTrigD, maxTrigF, maxTrigY, '最大配置');
          }
        } catch (error) {
          console.error('预测未来关卡时出错:', error);
          const currentEl = document.getElementById('currentPrediction');
          const maxEl = document.getElementById('maxPrediction');
          if (currentEl) currentEl.innerHTML = '<span style="color: var(--danger);">预测出错</span>';
          if (maxEl) maxEl.innerHTML = '<span style="color: var(--danger);">预测出错</span>';
        }
      }
      
      // 在计算完成后更新预测（已移除，避免重复调用）
      // const originalComputeWithForm = window.computeWithForm;
      // window.computeWithForm = async function() {
      //   const result = await originalComputeWithForm();
      //   updatePrediction(); // 使用新的预测函数
      //   return result;
      // };
      
      
      // 区块选择器功能
      function updateBlockVisibility() {
        const blocks = document.querySelectorAll('.config-block');
        blocks.forEach(block => {
          const blockType = block.dataset.block;
          const button = document.querySelector(`[data-block="${blockType}"].block-btn`);
          if (button) {
            if (button.classList.contains('active')) {
              block.classList.remove('hidden');
            } else {
              block.classList.add('hidden');
            }
          }
        });
      }
      
      // 区块折叠功能
      function toggleBlockCollapse(block) {
        const content = block.querySelector('.block-content');
        const toggle = block.querySelector('.block-toggle');
        
        if (content.classList.contains('expanded')) {
          content.classList.remove('expanded');
          content.classList.add('collapsed');
          block.classList.add('collapsed');
          toggle.textContent = '▶';
        } else {
          content.classList.remove('collapsed');
          content.classList.add('expanded');
          block.classList.remove('collapsed');
          toggle.textContent = '▼';
        }
      }
      
      // 初始化区块选择器事件监听
      document.querySelectorAll('.block-btn').forEach(button => {
        button.addEventListener('click', () => {
          button.classList.toggle('active');
          updateBlockVisibility();
        });
      });
      
      // 初始化区块折叠事件监听
      document.querySelectorAll('.config-block h4').forEach(header => {
        header.addEventListener('click', () => {
          toggleBlockCollapse(header.closest('.config-block'));
        });
      });
      
      // 初始化区块可见性
      updateBlockVisibility();
      
      // 悬浮窗功能
      let isDragging = false;
      let dragOffset = { x: 0, y: 0 };
      const floatingWindow = document.getElementById('floatingResult');
      const floatingHeader = floatingWindow.querySelector('.floating-header');
      const resultToggle = document.getElementById('resultToggle');
      const floatingClose = document.getElementById('floatingClose');
      
      // 开关控制悬浮窗显示/隐藏
      resultToggle.addEventListener('change', function() {
        if (this.checked) {
          floatingWindow.style.display = 'block';
        } else {
          floatingWindow.style.display = 'none';
        }
      });
      
      // 关闭按钮
      floatingClose.addEventListener('click', function(e) {
        e.stopPropagation();
        floatingWindow.style.display = 'none';
        resultToggle.checked = false;
      });
      
      // 拖拽功能
      floatingHeader.addEventListener('mousedown', function(e) {
        if (e.target.classList.contains('floating-close')) {
          return;
        }
        
        isDragging = true;
        const rect = floatingWindow.getBoundingClientRect();
        dragOffset.x = e.clientX - rect.left;
        dragOffset.y = e.clientY - rect.top;
        
        document.addEventListener('mousemove', handleDrag);
        document.addEventListener('mouseup', stopDrag);
        e.preventDefault();
      });
      
      function handleDrag(e) {
        if (!isDragging) return;
        
        const windowWidth = window.innerWidth;
        const windowHeight = window.innerHeight;
        const floatingWidth = floatingWindow.offsetWidth;
        const floatingHeight = floatingWindow.offsetHeight;
        
        let newX = e.clientX - dragOffset.x;
        let newY = e.clientY - dragOffset.y;
        
        // 限制不超出页面边界
        newX = Math.max(0, Math.min(newX, windowWidth - floatingWidth));
        newY = Math.max(0, Math.min(newY, windowHeight - floatingHeight));
        
        floatingWindow.style.left = newX + 'px';
        floatingWindow.style.top = newY + 'px';
        floatingWindow.style.right = 'auto';
      }
      
      function stopDrag() {
        isDragging = false;
        document.removeEventListener('mousemove', handleDrag);
        document.removeEventListener('mouseup', stopDrag);
      }
      
      // 初始化悬浮窗位置
      function initFloatingWindow() {
        const windowWidth = window.innerWidth;
        const windowHeight = window.innerHeight;
        
        // 先显示悬浮窗以获取实际尺寸
        floatingWindow.style.display = 'block';
        const floatingWidth = floatingWindow.offsetWidth;
        const floatingHeight = floatingWindow.offsetHeight;
        
        // 默认位置：右侧居中
        let defaultX = windowWidth - floatingWidth - 20;
        let defaultY = Math.max(120, (windowHeight - floatingHeight) / 2);
        
        // 确保不超出边界
        defaultX = Math.max(20, Math.min(defaultX, windowWidth - floatingWidth - 20));
        defaultY = Math.max(20, Math.min(defaultY, windowHeight - floatingHeight - 20));
        
        floatingWindow.style.left = defaultX + 'px';
        floatingWindow.style.top = defaultY + 'px';
        floatingWindow.style.right = 'auto';
        
        // 初始隐藏
        floatingWindow.style.display = 'none';
      }
      
      // 页面加载时初始化
      initFloatingWindow();
      
      // 窗口大小改变时重新定位
      window.addEventListener('resize', function() {
        if (floatingWindow.style.display !== 'none') {
          const windowWidth = window.innerWidth;
          const windowHeight = window.innerHeight;
          const floatingWidth = floatingWindow.offsetWidth;
          const floatingHeight = floatingWindow.offsetHeight;
          
          const currentLeft = parseInt(floatingWindow.style.left) || 0;
          const currentTop = parseInt(floatingWindow.style.top) || 0;
          
          let newX = Math.max(0, Math.min(currentLeft, windowWidth - floatingWidth));
          let newY = Math.max(0, Math.min(currentTop, windowHeight - floatingHeight));
          
          floatingWindow.style.left = newX + 'px';
          floatingWindow.style.top = newY + 'px';
        }
      });
      
      // 精度按钮功能
      document.querySelectorAll('.precision-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          // 移除所有active类
          document.querySelectorAll('.precision-btn').forEach(b => b.classList.remove('active'));
          // 添加active类到当前按钮
          btn.classList.add('active');
          // 更新精度值
          const precision = parseInt(btn.dataset.precision);
          // 触发计算更新（如果已经有结果的话）
          if (document.getElementById('resTotalSci').textContent !== '-') {
            computeWithForm();
          }
        });
      });
      
      // 获取当前精度的函数
      function getCurrentPrecision() {
        const activeBtn = document.querySelector('.precision-btn.active');
        return activeBtn ? parseInt(activeBtn.dataset.precision) : 2;
      }

      // 配色方案切换
      let lastActiveTheme = 'default'; // 记录上一个有效的主题
      
      document.querySelectorAll('.theme-option').forEach(option => {
        option.addEventListener('click', () => {
          // 获取主题名称
          const themeName = option.dataset.theme;
          
          // 检查是否是彩蛋主题
          if (themeName === 'easter-egg') {
            // 恢复之前的状态，不改变active类
            document.getElementById('easterEggModal').style.display = 'block';
            return;
          }
          
          // 更新记录的有效主题
          lastActiveTheme = themeName;
          
          // 移除所有active类
          document.querySelectorAll('.theme-option').forEach(opt => opt.classList.remove('active'));
          // 添加active类到当前选项
          option.classList.add('active');
          
          // 移除所有主题类
          document.body.classList.remove('theme-16QwQ', 'theme-buxingshx', 'theme-life', 'theme-purple', 'theme-rainbow', 'theme-wonderful', 'theme-16yyds');
          
          // 如果不是默认主题，添加对应的主题类
          if (themeName !== 'default') {
            document.body.classList.add(`theme-${themeName}`);
          }
          
          // 保存到localStorage
          localStorage.setItem('selectedTheme', themeName);
        });
      });
      
      // 彩蛋模态框关闭函数
      window.closeEasterEgg = function() {
        document.getElementById('easterEggModal').style.display = 'none';
      };
      
      
      // 轮播提示框功能
      const gameTips = [
        "进入关卡前和自摸时注意顺序哦",
        "吸星器，王之召唤等护身符+0分/×1番的时候先不要进链哦",
        "可以用迷雾印章、成长印章让盗印多吃印章哦",
        "商店买不到储备粮食的话，让改造王改绿卡试试看呢",
        "找生命的话，莱恩要放在墨镜猫右边哦",
        "找不到传导卡的时候，可以留恋人牌刷出传导后，用改造王改哦",
        "利用奶瓶刷的时候看一下岚星位置，控分到别过关先",
        "冲刺可以分两关，尽量在奖励关找轻松一些",
        "膨胀卡维plus升级两边的卡，如果左边是膨胀卡，那会出bug",
        "黑客变的盗印小心别把膨胀负重吃了hhhhhhh",
        "筒失效时，天恩别胡筒一色会断链子（条同理",
        "黑客流派的发育3w块以上是比较正常的星币数量o"
      ];
      
      let currentTipIndex = 0;
      let tipsInterval;
      
      function initTipsCarousel() {
        const tipsContent = document.getElementById('tipsContent');
        const tipsDots = document.getElementById('tipsDots');
        
        // 创建指示点
        gameTips.forEach((tip, index) => {
          const dot = document.createElement('div');
          dot.className = 'tips-dot';
          if (index === 0) dot.classList.add('active');
          dot.addEventListener('click', () => showTip(index));
          tipsDots.appendChild(dot);
        });
        
        // 开始自动轮播
        startTipsRotation();
        
        // 鼠标悬停时暂停轮播
        document.querySelector('.tips-carousel').addEventListener('mouseenter', stopTipsRotation);
        document.querySelector('.tips-carousel').addEventListener('mouseleave', startTipsRotation);
      }
      
      function showTip(index) {
        const tipsContent = document.getElementById('tipsContent');
        const dots = document.querySelectorAll('.tips-dot');
        
        // 移除当前活跃状态
        tipsContent.classList.remove('active');
        dots.forEach(dot => dot.classList.remove('active'));
        
        // 延迟后显示新内容
        setTimeout(() => {
          tipsContent.textContent = gameTips[index];
          tipsContent.classList.add('active');
          dots[index].classList.add('active');
          currentTipIndex = index;
        }, 250);
      }
      
      function startTipsRotation() {
        stopTipsRotation();
        tipsInterval = setInterval(() => {
          const nextIndex = (currentTipIndex + 1) % gameTips.length;
          showTip(nextIndex);
        }, 4000); // 每4秒切换一次
      }
      
      function stopTipsRotation() {
        if (tipsInterval) {
          clearInterval(tipsInterval);
          tipsInterval = null;
        }
      }
      
      // 加载保存的主题
      const savedTheme = localStorage.getItem('selectedTheme') || 'default';
      const themeOption = document.querySelector(`[data-theme="${savedTheme}"]`);
      if (themeOption) {
        themeOption.click();
      }
      
      // 为"选项（印章番数）"的输入框添加实时显示三种格式
      function updateStampDisplay() {
        const inputs = [
          { input: 'daoyin', display: 'daoyin_display' },
          { input: 'fuzhong', display: 'fuzhong_display' },
          { input: 'yueguang', display: 'yueguang_display' }
        ];
        
        inputs.forEach(({ input, display }) => {
          const inputEl = document.getElementById(input);
          const displayEl = document.getElementById(display);
          
          if (inputEl && displayEl) {
            const value = inputEl.value.trim();
            if (!value) {
              displayEl.textContent = '';
              return;
            }
            
            // 尝试解析输入值
            let num = parseFloat(value);
            if (isNaN(num)) {
              const sciStr = parseChinaJiLocal(value);
              if (sciStr) {
                num = parseFloat(sciStr);
              }
            }
            
            if (!isNaN(num)) {
              const formats = formatNumberDisplay(num, 2);
              let displayText = '';
              
              if (formats.raw) displayText += formats.raw;
              if (formats.raw && formats.sci) displayText += ' / ';
              if (formats.sci) displayText += formats.sci;
              if (formats.cn && num >= 10000) {
                displayText += ' / ' + formats.cn;
              }
              
              displayEl.textContent = displayText;
            } else {
              displayEl.textContent = '';
            }
          }
        });
      }
      
      // 为印章番数输入框添加事件监听器
      ['daoyin', 'fuzhong', 'yueguang'].forEach(id => {
        const input = document.getElementById(id);
        if (input) {
          input.addEventListener('input', updateStampDisplay);
        }
      });
      
      // 初始化显示
      updateStampDisplay();
      
      
      // 确认起始关按钮事件监听器（带反馈）
      document.getElementById('unlockApply').addEventListener('click', ()=>{
        const button = document.getElementById('unlockApply');
        const originalText = button.textContent;
        
        // 显示反馈
        button.textContent = '✓ 已确认';
        button.style.background = 'var(--ok)';
        button.style.color = 'var(--card)';
        
        // 刷新页面
        renderPage5();
        
        // 2秒后恢复原状
        setTimeout(() => {
          button.textContent = originalText;
          button.style.background = '';
          button.style.color = '';
        }, 2000);
      });
      
      // 初始化轮播提示框
      initTipsCarousel();

      // 卡片折叠/展开功能
      document.querySelectorAll('.card-toggle').forEach(button => {
        button.addEventListener('click', () => {
          const targetId = button.dataset.target;
          const content = document.getElementById(targetId);
          const isCollapsed = content.classList.contains('collapsed');
          
          if (isCollapsed) {
            content.classList.remove('collapsed');
            button.textContent = '−';
          } else {
            content.classList.add('collapsed');
            button.textContent = '+';
          }
        });
      });
      
      // 区块折叠/展开功能
      document.querySelectorAll('.config-block h4').forEach(header => {
        header.addEventListener('click', () => {
          const block = header.closest('.config-block');
          const content = block.querySelector('.block-content');
          const toggle = block.querySelector('.block-toggle');
          const isCollapsed = block.classList.contains('collapsed');
          
          if (isCollapsed) {
            block.classList.remove('collapsed');
            content.classList.remove('collapsed');
            content.classList.add('expanded');
            toggle.textContent = '▼';
          } else {
            block.classList.add('collapsed');
            content.classList.remove('expanded');
            content.classList.add('collapsed');
            toggle.textContent = '▶';
          }
        });
      });

      // 数字输入控件功能
      document.querySelectorAll('.number-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
          e.preventDefault();
          const target = btn.dataset.target;
          const action = btn.dataset.action;
          const input = document.getElementById(target);
          
          if (input) {
            let value = parseInt(input.value) || 0;
            if (action === 'increase') {
              value += 1;
            } else if (action === 'decrease') {
              value = Math.max(0, value - 1);
            }
            input.value = value;
            
            // 触发input事件，确保其他监听器能收到更新
            input.dispatchEvent(new Event('input', { bubbles: true }));
          }
        });
      });

      // 王之召唤开关
      const kingEnabled = document.getElementById('kingEnabled');
      const kingBox = document.getElementById('kingBox');
      if (kingEnabled && kingBox) {
        kingEnabled.addEventListener('change', ()=>{
          kingBox.style.display = kingEnabled.checked ? 'block' : 'none';
          // 重新渲染关卡目标分模块以更新王之召唤列的显示
          renderPage5();
          // 重新计算并更新预测
          if (document.getElementById('btn')) {
            document.getElementById('btn').click();
          }
        });
      }
      
      // 王之召唤触发次数输入框事件监听器
      const trigKInput = document.getElementById('trigK');
      if (trigKInput) {
        let trigKTimeout = null;
        trigKInput.addEventListener('input', () => {
          if (trigKTimeout) {
            clearTimeout(trigKTimeout);
          }
          trigKTimeout = setTimeout(() => {
            // 重新计算并更新预测
            if (document.getElementById('btn')) {
              document.getElementById('btn').click();
            }
          }, 300);
        });
      }
      
      const maxTrigKInput = document.getElementById('maxTrigK');
      if (maxTrigKInput) {
        let maxTrigKTimeout = null;
        maxTrigKInput.addEventListener('input', () => {
          if (maxTrigKTimeout) {
            clearTimeout(maxTrigKTimeout);
          }
          maxTrigKTimeout = setTimeout(() => {
            // 重新计算并更新预测
            if (document.getElementById('btn')) {
              document.getElementById('btn').click();
            }
          }, 300);
        });
      }
      
      // 绑定预测更新按钮（移除重复绑定，统一在底部使用防抖机制）
      // document.getElementById('updatePrediction').addEventListener('click', updatePrediction);
      
      // 格式化数字显示（用于预测功能）
      function formatPredictionNumber(value, digits = 2) {
        if (!value || value === '-' || value === 0) return '0';
        
        let originalValue = value;
        let sciString = '';
        
        if (typeof value === 'string') {
          // 先尝试解析中国大数字系统格式
          const parsed = parseChinaJiLocal(value);
          originalValue = parsed || value;
          
          // 检查是否为科学计数法格式
          const sciMatch = originalValue.match(/^\s*([-+]?\d+(?:\.\d+)?)e([-+]?\d+)\s*$/i);
          if (sciMatch) {
            const coeff = parseFloat(sciMatch[1]);
            const expo = parseInt(sciMatch[2], 10);
            
            // 如果指数超过 JavaScript 安全范围，直接使用字符串处理
            if (expo > 1000 || !isFinite(coeff) || !isFinite(expo)) {
              sciString = originalValue;
            } else {
              const num = parseFloat(originalValue);
              if (isFinite(num)) {
                // 1万以下的数不显示科学计数法
                if (num < 10000) {
                  return num.toFixed(digits);
                }
                sciString = num.toExponential(15);
              } else {
                sciString = originalValue;
              }
            }
          } else {
            // 尝试解析为普通数字
            const num = parseFloat(originalValue);
            if (isFinite(num)) {
              // 1万以下的数不显示科学计数法
              if (num < 10000) {
                return num.toFixed(digits);
              }
              sciString = num.toExponential(15);
            } else {
              // 如果 parseFloat 失败，可能是超大数字，尝试直接处理
              sciString = originalValue;
            }
          }
        } else {
          const num = parseFloat(value);
          if (isFinite(num)) {
            // 1万以下的数不显示科学计数法
            if (num < 10000) {
              return num.toFixed(digits);
            }
            sciString = num.toExponential(15);
          } else {
            sciString = value.toString();
          }
        }
        
        // 如果 sciString 为空或无效，返回 '-'
        if (!sciString) return '-';
        
        // 生成科学计数法显示
        let sciDisplay = sciString;
        if (sciString.includes('e') || sciString.includes('E')) {
          const sciMatch = sciString.match(/^\s*([-+]?\d+(?:\.\d+)?)e([-+]?\d+)\s*$/i);
          if (sciMatch) {
            const coeff = parseFloat(sciMatch[1]);
            const expo = parseInt(sciMatch[2], 10);
            if (isFinite(coeff) && isFinite(expo)) {
              sciDisplay = `${coeff.toFixed(digits)}e${expo}`;
            }
          }
        }
        
        // 中国大数字系统转换
        const cn = formatChinaJiLocal(sciString, digits);
        
        return `${sciDisplay} / ${cn}`;
      }
      
      // 格式化目标分数显示（显示原始样式）
      function formatTargetScore(value) {
        if (!value || value === '-' || value === 0) return '0';
        
        // 先尝试解析中国大数字系统格式
        const parsed = parseChinaJiLocal(value);
        const num = parseFloat(parsed || value);
        
        // 若超出 JS Number 范围或解析失败，直接使用原始字符串 + 中国大数格式
        if (!isFinite(num) || isNaN(num)) {
          const raw = String(value);
          const cn = formatChinaJiLocal(raw, 2);
          return `${raw} / ${cn}`;
        }
        
        // 1万以下的数不显示科学计数法
        if (num < 10000) {
          return num.toString();
        }
        
        // 科学计数法
        const sci = num.toExponential(2);
        
        // 中国大数字系统
        const cn = formatChinaJiLocal(num.toString(), 2);
        
        return `${sci} / ${cn}`;
      }
      
      // 比较得分和目标分的辅助函数（处理科学计数法格式）
      function compareScores(score, targetStr) {
        if (!targetStr || targetStr === '-') return true; // 没有目标分则通过
        
        // 解析目标分为科学计数法格式
        const parsedTarget = parseChinaJiLocal(targetStr) || targetStr;
        
        // 如果目标分是科学计数法格式（如 "5.70E+310"）
        if (typeof parsedTarget === 'string' && parsedTarget.includes('E')) {
          // 将得分转换为科学计数法进行比较
          const scoreStr = score.toExponential();
          return compareScientificNotation(scoreStr, parsedTarget);
        }
        
        // 普通数字比较
        const targetNum = parseFloat(parsedTarget);
        if (isFinite(targetNum)) {
          return score >= targetNum;
        }
        
        // 如果无法解析目标分，默认通过
        return true;
      }
      
      // 比较两个科学计数法字符串
      function compareScientificNotation(scoreStr, targetStr) {
        try {
          // 解析科学计数法
          const parseSci = (str) => {
            const match = str.match(/^([+-]?\d+(?:\.\d+)?)[eE]([+-]?\d+)$/);
            if (!match) return null;
            return {
              coefficient: parseFloat(match[1]),
              exponent: parseInt(match[2])
            };
          };
          
          const scoreParts = parseSci(scoreStr);
          const targetParts = parseSci(targetStr);
          
          if (!scoreParts || !targetParts) return true;
          
          // 比较指数
          if (scoreParts.exponent > targetParts.exponent) return true;
          if (scoreParts.exponent < targetParts.exponent) return false;
          
          // 指数相同，比较系数
          return scoreParts.coefficient >= targetParts.coefficient;
        } catch (e) {
          console.warn('科学计数法比较失败:', e);
          return true;
        }
      }
      
      // 预测功能 - 复用计算结果区块的计算逻辑
      async function updatePrediction() {
        try {
          // 使用computeWithForm的计算逻辑来获取准确的结果
          const currentLevel = document.getElementById('levelSelect').value;
          const baseScore = parseFloat(document.getElementById('baseScore').value) || 0;
          
          if (baseScore <= 0) {
            // 清空显示
            const clearElement = (id) => {
              const el = document.getElementById(id);
              if (el) el.textContent = '请先进行计算';
            };
            
            clearElement('predCurrentLevelTarget');
            clearElement('predCurrentScore');
            clearElement('predMaxScore');
            clearElement('predBreakdown');
            clearElement('currentPrediction');
            clearElement('maxPrediction');
            return;
          }
          
          // 调用computeWithForm获取计算结果，但不更新UI
          const result = await computeWithFormInternal();
          
          if (result) {
            // 获取触发次数
            const trigD = parseInt(document.getElementById('trigD').value) || 0;
            const trigF = parseInt(document.getElementById('trigF').value) || 0;
            const trigY = parseInt(document.getElementById('trigY').value) || 0;
            const maxTrigD = parseInt(document.getElementById('theoD').value) || 0;
            const maxTrigF = parseInt(document.getElementById('theoF').value) || 0;
            const maxTrigY = parseInt(document.getElementById('theoY').value) || 0;
            
            // 获取护身符数值
            const daoyinValue = parseFloat(document.getElementById('daoyin').value) || 1;
            const fuzhongValue = parseFloat(document.getElementById('fuzhong').value) || 1;
            const yueguangValue = parseFloat(document.getElementById('yueguang').value) || 1;
            
            // 更新当前关卡信息与目标分
            const targetScoreStr = LEVEL_TARGETS[currentLevel];
            
            document.getElementById('predCurrentLevelTarget').innerHTML = `
              当前关卡：${currentLevel}  目标分:${formatTargetScore(targetScoreStr)}
            `;
            
            // 使用API返回的结果更新预测显示
            document.getElementById('predCurrentScore').textContent = result.totalScore || '-';
            document.getElementById('predMaxScore').textContent = result.theoreticalTotalScore || '-';
            
            // 更新分解（番数与触发次数）显示 - 使用API返回的准确数据
            const dv = result.breakdown?.daoyin?.value;
            const fv = result.breakdown?.fuzhong?.value;
            const yv = result.breakdown?.yueguang?.value;
            const dvSci = dv != null ? parseFloat(dv).toExponential(2) : '-';
            const fvSci = fv != null ? parseFloat(fv).toExponential(2) : '-';
            const yvSci = yv != null ? parseFloat(yv).toExponential(2) : '-';
            const dvCn = dv != null ? formatChinaJiLocal(dvSci, 2) : '-';
            const fvCn = fv != null ? formatChinaJiLocal(fvSci, 2) : '-';
            const yvCn = yv != null ? formatChinaJiLocal(yvSci, 2) : '-';
            
            document.getElementById('predBreakdown').innerHTML = `
              <div style="flex:1;">盗印 番数=${dvSci} / ${dvCn}  触发=${result.breakdown?.daoyin?.triggers ?? '-'}</div>
              <div style="flex:1;">负重 番数=${fvSci} / ${fvCn}  触发=${result.breakdown?.fuzhong?.triggers ?? '-'}</div>
              <div style="flex:1;">月光 番数=${yvSci} / ${yvCn}  触发=${result.breakdown?.yueguang?.triggers ?? '-'}</div>
            `;
            
            // 更新触发次数显示
            document.getElementById('currentDaoyinTriggers').textContent = trigD;
            document.getElementById('currentFuzhongTriggers').textContent = trigF;
            document.getElementById('currentYueguangTriggers').textContent = trigY;
            document.getElementById('maxDaoyinTriggers').textContent = maxTrigD;
            document.getElementById('maxFuzhongTriggers').textContent = maxTrigF;
            document.getElementById('maxYueguangTriggers').textContent = maxTrigY;
            
            // 计算预测 - 使用后端API进行准确计算
            const currentPrediction = await calculatePrediction(baseScore, trigD, trigF, trigY, currentLevel, daoyinValue, fuzhongValue, yueguangValue, 'current');
            const maxPrediction = await calculatePrediction(baseScore, maxTrigD, maxTrigF, maxTrigY, currentLevel, daoyinValue, fuzhongValue, yueguangValue, 'max');
            
            document.getElementById('currentPrediction').innerHTML = currentPrediction;
            document.getElementById('maxPrediction').innerHTML = maxPrediction;
          }
        } catch (err) {
          console.error('预测更新失败:', err);
          const currentEl = document.getElementById('currentPrediction');
          const maxEl = document.getElementById('maxPrediction');
          if (currentEl) currentEl.innerHTML = '<span style="color: var(--danger);">预测出错</span>';
          if (maxEl) maxEl.innerHTML = '<span style="color: var(--danger);">预测出错</span>';
        }
      }
      
      // 内部计算函数 - 复用computeWithForm的逻辑但不更新UI
      async function computeWithFormInternal() {
        try {
          const basePayload = (() => {
            const levelConfig = { targetScore: $('targetScore').value.trim() };
            if (document.getElementById('kingEnabled') && document.getElementById('kingEnabled').checked) {
              levelConfig.kingCallInitialMultiplier = '1'; // 王之召唤初始番数固定为1
              const t = $('trigK') ? $('trigK').value.trim() : '4';
              if (t) levelConfig.kingCallTriggers = Number(t);
              levelConfig.kingCallBase = '30'; // 基础番数固定为30
            }
            const sequence = { baseScore: $('baseScore').value.trim(), items: [] };

            const options = {
              daoyinValue: $('daoyin').value.trim(),
              fuzhongValue: $('fuzhong').value.trim(),
              yueguangValue: $('yueguang').value.trim(),
              overrideTriggers: {
                daoyin: Number($('trigD').value.trim() || '0'),
                fuzhong: Number($('trigF').value.trim() || '0'),
                yueguang: Number($('trigY').value.trim() || '0'),
              },
              overrideTheoreticalMaxes: {
                daoyin: Number($('theoD').value.trim() || '0'),
                fuzhong: Number($('theoF').value.trim() || '0'),
                yueguang: Number($('theoY').value.trim() || '0'),
                kingCall: Number($('maxTrigK').value.trim() || '0') // 添加王之召唤理论最大触发次数
              }
            };
            return { levelConfig, sequence, options };
          })();
          if (!basePayload) return null;

          const payload = basePayload;
          // 覆盖胡牌番数 - 如果有王之召唤，使用王之召唤计算出的胡牌番数
          const kingEnabled = document.getElementById('kingEnabled')?.checked;
          if (kingEnabled) {
            // 计算王之召唤乘数来替换胡牌番数
            const currentLevel = $('levelSelect')?.value || 'Ex61';
            const all = computeRecommendedAll();
            const levelData = all[currentLevel];
            
            if (levelData?.actualK && levelData?.actualKH) {
              const currentKingFan = levelData.actualK;
              const winCountFromSettings = parseFloat($('finalMulInput').value) || 1;
              const triggerCount = parseInt($('trigK').value) || 4;
              
              // 使用统一的王之召唤乘数计算函数
              const kingMultiplier = calculateKingCallMultiplier(currentKingFan, triggerCount, winCountFromSettings);
              
              // 使用王之召唤乘数直接替换胡牌番数
              // console.log('🎯 后端调用王之召唤计算:', {
              //   currentKingFan,
              //   winCountFromSettings,
              //   triggerCount,
              //   kingMultiplier,
              //   finalMultiplierOverride: kingMultiplier.toString()
              // });
              payload.options.finalMultiplierOverride = kingMultiplier.toString();
              
              // 如果王之召唤开启，还需要计算理论最大触发次数对应的王之召唤乘数
              const maxTrigK = parseInt($('maxTrigK').value) || 4;
              // console.log('🔍 前端王之召唤理论最大触发次数调试:', {
              //   currentKingFan,
              //   maxTrigK,
              //   winCountFromSettings,
              //   triggerCount
              // });
              
              if (maxTrigK > 0) {
                const theoreticalKingMultiplier = calculateKingCallMultiplier(currentKingFan, maxTrigK, winCountFromSettings);
                payload.options.theoreticalFinalMultiplierOverride = theoreticalKingMultiplier.toString();
                // console.log('🎯 前端计算王之召唤理论最大乘数:', theoreticalKingMultiplier.toString());
              } else {
                // 如果王之召唤理论最大触发次数为0，使用原始胡牌番数
                payload.options.theoreticalFinalMultiplierOverride = $('finalMulInput').value.trim();
                // console.log('🎯 王之召唤理论最大触发次数为0，使用原始胡牌番数:', $('finalMulInput').value.trim());
              }
            } else {
          payload.options.finalMultiplierOverride = $('finalMulInput').value.trim();
              // 王之召唤关闭时，理论最大乘数也使用原始胡牌番数
              payload.options.theoreticalFinalMultiplierOverride = $('finalMulInput').value.trim();
            }
          } else {
            payload.options.finalMultiplierOverride = $('finalMulInput').value.trim();
          }
          // 将三类番数输入也允许中文大数：预解析为科学计数
          ['daoyinValue','fuzhongValue','yueguangValue'].forEach(k=>{
            const v = payload.options[k];
            const p = parseChinaJiLocal(v);
            if (p) payload.options[k] = p;
          });
          // baseScore/targetScore 亦本地解析
          const pt = parseChinaJiLocal(payload.levelConfig.targetScore); if (pt) payload.levelConfig.targetScore = pt;
          const pb = parseChinaJiLocal(payload.sequence.baseScore); if (pb) payload.sequence.baseScore = pb;
          // 触发次数与理论最大次数确保为数字
          payload.options.overrideTriggers = payload.options.overrideTriggers || {};
          payload.options.overrideTheoreticalMaxes = payload.options.overrideTheoreticalMaxes || {};
          ['daoyin','fuzhong','yueguang','kingCall'].forEach(k=>{
            payload.options.overrideTriggers[k] = Number(payload.options.overrideTriggers[k]||0);
            payload.options.overrideTheoreticalMaxes[k] = Number(payload.options.overrideTheoreticalMaxes[k]||0);
          });

          const resp = await fetch(api, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload),
          });
          const data = await resp.json();
          return data;
        } catch (err) {
          console.error('内部计算失败:', err);
          return null;
        }
      }
      
      async function calculatePrediction(baseScore, trigD, trigF, trigY, startLevel, daoyinValue = 1, fuzhongValue = 1, yueguangValue = 1, type = 'current') {
        console.log('calculatePrediction', baseScore, trigD, trigF, trigY, startLevel, daoyinValue, fuzhongValue, yueguangValue, type);
        const currentLevelIdx = keyOrder.indexOf(startLevel);
        if (currentLevelIdx === -1) return '无效关卡';
        
        // 获取胡牌番数（最终番数）
        const finalMultiplier = parseFloat(document.getElementById('finalMulInput').value) || 1;
        
        // 准备关卡数据，只包含当前关卡之后的关卡
        const futureLevels = {};
        const all = computeRecommendedAll();
        
        for (let i = currentLevelIdx + 1; i < keyOrder.length; i++) {
          const levelKey = keyOrder[i];
          const levelData = all[levelKey];
          const targetScoreStr = LEVEL_TARGETS[levelKey];
          
          if (levelData && targetScoreStr) {
            // 确保番数值转换为科学计数法字符串格式，以便后端正确解析大数字
            const formatValueForBackend = (value) => {
              if (!value || value === 0) return '1';
              const num = parseFloat(value);
              if (!isFinite(num)) return '1';
              // 使用科学计数法格式，确保大数字不会丢失精度
              return num.toExponential(15);
            };
            
            futureLevels[levelKey] = {
              targetScore: targetScoreStr,
              daoyinValue: formatValueForBackend(levelData.actualD || 1),
              fuzhongValue: formatValueForBackend(levelData.actualF || 1),
              yueguangValue: formatValueForBackend(levelData.actualY || 1),
              kingValue: formatValueForBackend(levelData.actualK || 1) // 添加王之召唤番数
            };
          }
        }
        
        try {
          // 调用后端API进行预测计算（显式 CORS 与禁用缓存）
          const response = await fetch(`${API_BASE}/api/predict`, {
            method: 'POST',
            mode: 'cors',
            cache: 'no-store',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              baseScore,
              finalMultiplier,
              currentLevel: startLevel,
              levelData: futureLevels,
              type,
              triggers: {
                daoyin: trigD,
                fuzhong: trigF,
                yueguang: trigY
              },
              kingCallData: {
                enabled: document.getElementById('kingEnabled')?.checked || false,
                triggers: parseInt($('trigK')?.value) || 4,
                maxTriggers: parseInt($('maxTrigK')?.value) || 4,
                winCount: parseFloat($('finalMulInput')?.value) || 1
              }
            })
          });
          
          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }
          
          const result = await response.json();
          
          if (result.error) {
            throw new Error(result.message || result.error);
          }
          
          // 处理预测结果
            if (result.canPass) {
            // 写入快速状态（全部通关时仅清空或显示一个总徽章）
            try {
              const quickEl = type === 'current' ? document.getElementById('currentPredQuickStatus') : document.getElementById('maxPredQuickStatus');
              if (quickEl) {
                quickEl.innerHTML = '<span class="predict-badge ok">全部通关</span>';
              }
            } catch (_) {}
            return '<div class="predict-list"><div class="predict-row"><span class="predict-badge ok">全部通关</span><span class="predict-meta">该配置可超过所有后续关卡</span></div></div>';
          } else {
            // 若所选关卡已处于（或在）首个失败关卡之后，则快速状态仅显示“所选关卡：败北”
            const startIdx = keyOrder.indexOf(startLevel);
            const failIdx = keyOrder.indexOf(result.firstFailedLevel);
            const selectedHasAlreadyFailed = (failIdx !== -1 && startIdx !== -1 && startIdx >= failIdx);

            if (selectedHasAlreadyFailed) {
              try {
                const quickEl = type === 'current' ? document.getElementById('currentPredQuickStatus') : document.getElementById('maxPredQuickStatus');
                if (quickEl) quickEl.innerHTML = `<span class="predict-badge fail">${startLevel}：败北</span>`;
              } catch (_) {}
            }

            let html = '<div class="predict-list">';
            const triggerText = result.triggerText;
            
            // 显示最后一个通过的关卡（仅当 level/score/target 同时存在）
            if (result.lastValidLevel && result.lastValidScore && result.lastValidTarget) {
              const lastValidDisplay = formatTargetScore(result.lastValidScore);
              const lastValidTargetDisplay = formatTargetScore(result.lastValidTarget);
              html += `
                <div class="predict-row">
                  <span class="predict-badge ok">通过</span>
                  <span class="prediction-score-highlight">${lastValidDisplay}</span>
                  <span class="predict-meta">≥ ${lastValidTargetDisplay}</span>
                  <span class="predict-meta">@ ${result.lastValidLevel}</span>
                </div>
              `;
            }
            
            // 第一个无法通过的关卡
            const failedDisplay = formatTargetScore(result.firstFailedScore);
            const targetDisplay = formatTargetScore(result.firstFailedTarget);
            html += `
              <div class="predict-row">
                <span class="predict-badge fail">败北</span>
                <span class="prediction-score-highlight">${failedDisplay}</span>
                <span class="predict-meta">< ${targetDisplay}</span>
                <span class="prediction-level-warning">@ ${result.firstFailedLevel}</span>
              </div>
            `;
            
            // 标题行右侧快速状态：复制“关卡：通过 / 关卡：败北”
            try {
              if (!selectedHasAlreadyFailed) {
                const hasValidPass = !!(result.lastValidLevel && result.lastValidScore && result.lastValidTarget);
                const quickHtml = `
                  ${hasValidPass ? `<span class=\"predict-badge ok\">${result.lastValidLevel}：通过</span>` : ''}
                  <span class=\"predict-badge fail\">${result.firstFailedLevel}：败北</span>
                `;
                const quickEl = type === 'current' ? document.getElementById('currentPredQuickStatus') : document.getElementById('maxPredQuickStatus');
                if (quickEl) quickEl.innerHTML = quickHtml;
              }
            } catch (_) {}

            html += '</div>';
            return html;
          }
          
        } catch (error) {
          console.error('预测计算失败:', error);
          return `<span style="color: var(--danger);">预测计算失败: ${error.message}</span>`;
        }
      }
      
      // 防止重复绑定事件监听器
      let btnListenerAdded = false;
      let updatePredictionListenerAdded = false;
      
      // 监听计算按钮点击，更新预测
      if (!btnListenerAdded) {
        const btn = document.getElementById('btn');
        if (btn) {
          btn.addEventListener('click', () => {
            // 先执行计算，然后更新预测
            computeWithForm().then(() => {
              updatePrediction();
            });
          });
          btnListenerAdded = true;
        }
      }
      
      // 监听更新预测按钮点击
      if (!updatePredictionListenerAdded) {
        const updatePredictionBtn = document.getElementById('updatePrediction');
        if (updatePredictionBtn) {
          updatePredictionBtn.addEventListener('click', () => {
            updatePrediction();
          });
          updatePredictionListenerAdded = true;
        }
      }
      
      // 添加防抖机制，避免重复调用
      let predictionUpdateTimeout = null;
      const debouncedUpdatePrediction = () => {
        if (predictionUpdateTimeout) {
          clearTimeout(predictionUpdateTimeout);
        }
        predictionUpdateTimeout = setTimeout(() => {
          updatePrediction();
        }, 100);
      };
      
      // 页面初始化时触发关卡选择联动
      document.addEventListener('DOMContentLoaded', () => {
        // Tab切换功能
        let currentTab = 'hacker';
        const moonlightToggle = document.getElementById('moonlightToggle');
        const moonlightToggleText = document.getElementById('moonlightToggleText');
        
        // 页面初始化时显示月光和负重开关（因为默认是黑客流派标签页）
        const tabMoonlightToggle = document.getElementById('tabMoonlightToggle');
        const tabFuzhongToggle = document.getElementById('tabFuzhongToggle');
        if (tabMoonlightToggle) tabMoonlightToggle.style.display = 'block';
        if (tabFuzhongToggle) tabFuzhongToggle.style.display = 'block';
        
        // Ant Design风格Tab事件监听
        document.querySelectorAll('.antd-tab-tab').forEach(tabElement => {
          tabElement.addEventListener('click', () => {
            const tab = tabElement.dataset.tab;
            currentTab = tab;
            
            // 更新tab状态
            document.querySelectorAll('.antd-tab-tab').forEach(tab => tab.classList.remove('antd-tab-tab-active'));
            tabElement.classList.add('antd-tab-tab-active');
            
            // 显示/隐藏月光和负重开关
            const tabMoonlightToggle = document.getElementById('tabMoonlightToggle');
            const tabFuzhongToggle = document.getElementById('tabFuzhongToggle');
            if (tab === 'hacker') {
              tabMoonlightToggle.style.display = 'block';
              tabFuzhongToggle.style.display = 'block';
            } else {
              tabMoonlightToggle.style.display = 'none';
              tabFuzhongToggle.style.display = 'none';
              // 切换到指数三大件时，自动显示月光和负重相关参数
              if (tab === 'index') {
                const moonlightToggle = document.getElementById('moonlightToggle');
                if (moonlightToggle) {
                  moonlightToggle.checked = true;
                  toggleMoonlightBlocks(true);
                }
                const fuzhongToggle = document.getElementById('fuzhongToggle');
                if (fuzhongToggle) {
                  fuzhongToggle.checked = true;
                  toggleFuzhongBlocks(true);
                }
                renderPage5();
              }
            }
          });
        });
        
        // 月光开关事件监听
        if (moonlightToggle) {
          moonlightToggle.addEventListener('change', (e) => {
            const enabled = e.target.checked;
            if (moonlightToggleText) {
              moonlightToggleText.textContent = enabled ? '月光' : '月光';
            }
            
            // 控制月光相关区块的显示/隐藏
            toggleMoonlightBlocks(enabled);
            
            // 如果关闭月光，将月光触发次数设为0
            if (!enabled) {
              document.getElementById('trigY').value = '0';
              document.getElementById('theoY').value = '0';
            }
            
            // 重新渲染关卡目标分模块以更新月光列的显示
            renderPage5();
            
            // 触发计算更新
            if (document.getElementById('btn')) {
              document.getElementById('btn').click();
            }
          });
        }
        
        // 负重开关事件监听
        const fuzhongToggle = document.getElementById('fuzhongToggle');
        const fuzhongToggleText = document.getElementById('fuzhongToggleText');
        if (fuzhongToggle) {
          fuzhongToggle.addEventListener('change', (e) => {
            const enabled = e.target.checked;
            if (fuzhongToggleText) {
              fuzhongToggleText.textContent = enabled ? '负重' : '负重';
            }
            
            // 控制负重相关区块的显示/隐藏
            toggleFuzhongBlocks(enabled);
            
            // 如果关闭负重，将负重触发次数设为0
            if (!enabled) {
              document.getElementById('trigF').value = '0';
              document.getElementById('theoF').value = '0';
            }
            
            // 重新渲染关卡目标分模块以更新负重列的显示
            renderPage5();
            
            // 触发计算更新
            if (document.getElementById('btn')) {
              document.getElementById('btn').click();
            }
          });
        }
        
        // 控制月光相关区块的显示/隐藏
        function toggleMoonlightBlocks(enabled) {
          const moonlightBlocks = [
            'values', // 数值设置中的月光番数
            'triggers' // 触发次数中的月光相关部分
          ];
          
          moonlightBlocks.forEach(blockId => {
            const block = document.querySelector(`[data-block="${blockId}"]`);
            if (block) {
              if (!enabled) {
                // 隐藏月光相关内容
                const moonlightInputs = block.querySelectorAll('#yueguang, #trigY, #theoY');
                const moonlightLabels = block.querySelectorAll('label[for="yueguang"], label[for="trigY"], label[for="theoY"]');
                const moonlightDisplays = block.querySelectorAll('#yueguang_display');
                
                [...moonlightInputs, ...moonlightLabels, ...moonlightDisplays].forEach(el => {
                  if (el) el.style.display = 'none';
                });
                
                // 隐藏月光相关的表格行
                const allRows = block.querySelectorAll('tr');
                allRows.forEach(row => {
                  if (row.textContent.includes('月光')) {
                    row.style.display = 'none';
                  }
                });
              } else {
                // 显示月光相关内容
                const moonlightInputs = block.querySelectorAll('#yueguang, #trigY, #theoY');
                const moonlightLabels = block.querySelectorAll('label[for="yueguang"], label[for="trigY"], label[for="theoY"]');
                const moonlightDisplays = block.querySelectorAll('#yueguang_display');
                
                [...moonlightInputs, ...moonlightLabels, ...moonlightDisplays].forEach(el => {
                  if (el) el.style.display = '';
                });
                
                // 显示月光相关的表格行
                const moonlightRows = block.querySelectorAll('tr');
                moonlightRows.forEach(row => {
                  if (row.textContent.includes('月光')) {
                    row.style.display = '';
                  }
                });
              }
            }
          });
        }
        
        // 控制负重相关区块的显示/隐藏
        function toggleFuzhongBlocks(enabled) {
          const fuzhongBlocks = [
            'values', // 数值设置中的负重番数
            'triggers' // 触发次数中的负重相关部分
          ];
          
          fuzhongBlocks.forEach(blockId => {
            const block = document.querySelector(`[data-block="${blockId}"]`);
            if (block) {
              if (!enabled) {
                // 隐藏负重相关内容
                const fuzhongInputs = block.querySelectorAll('#fuzhong, #trigF, #theoF');
                const fuzhongLabels = block.querySelectorAll('label[for="fuzhong"], label[for="trigF"], label[for="theoF"]');
                const fuzhongDisplays = block.querySelectorAll('#fuzhong_display');
                
                [...fuzhongInputs, ...fuzhongLabels, ...fuzhongDisplays].forEach(el => {
                  if (el) el.style.display = 'none';
                });
                
                // 隐藏负重相关的表格行
                const allRows = block.querySelectorAll('tr');
                allRows.forEach(row => {
                  if (row.textContent.includes('负重')) {
                    row.style.display = 'none';
                  }
                });
              } else {
                // 显示负重相关内容
                const fuzhongInputs = block.querySelectorAll('#fuzhong, #trigF, #theoF');
                const fuzhongLabels = block.querySelectorAll('label[for="fuzhong"], label[for="trigF"], label[for="theoF"]');
                const fuzhongDisplays = block.querySelectorAll('#fuzhong_display');
                
                [...fuzhongInputs, ...fuzhongLabels, ...fuzhongDisplays].forEach(el => {
                  if (el) el.style.display = '';
                });
                
                // 显示负重相关的表格行
                const fuzhongRows = block.querySelectorAll('tr');
                fuzhongRows.forEach(row => {
                  if (row.textContent.includes('负重')) {
                    row.style.display = '';
                  }
                });
              }
            }
          });
        }
        
        // 初始化时触发关卡选择的change事件，确保联动生效
        const levelSelect = document.getElementById('levelSelect');
        if (levelSelect) {
          levelSelect.dispatchEvent(new Event('change'));
        }
        
        // 印章消失计数功能
        let sealCounter = 0;
        let selectedSealLevel = '';
        let selectedGrowthType = '';
        let originalSealValue = 0;
        
        // 将变量暴露到全局作用域，以便其他函数可以访问
        window.selectedSealLevel = selectedSealLevel;
        
        // Lolipop随机动画功能 - 20种动画效果
        const lolipopAnimations = [
          { name: 'lolipop-bounce', duration: '1.5s', timing: 'ease-in-out' },
          { name: 'lolipop-spin', duration: '2s', timing: 'linear' },
          { name: 'lolipop-wiggle', duration: '0.8s', timing: 'ease-in-out' },
          { name: 'lolipop-pulse', duration: '1.2s', timing: 'ease-in-out' },
          { name: 'lolipop-float', duration: '2.5s', timing: 'ease-in-out' },
          { name: 'lolipop-shake', duration: '1s', timing: 'ease-in-out' },
          { name: 'lolipop-zoom', duration: '1.8s', timing: 'ease-in-out' },
          { name: 'lolipop-swing', duration: '1.3s', timing: 'ease-in-out' },
          { name: 'lolipop-flip', duration: '2.2s', timing: 'ease-in-out' },
          { name: 'lolipop-dance', duration: '2s', timing: 'ease-in-out' },
          { name: 'lolipop-twist', duration: '1.6s', timing: 'ease-in-out' },
          { name: 'lolipop-jump', duration: '0.6s', timing: 'ease-in-out' },
          { name: 'lolipop-rock', duration: '1.4s', timing: 'ease-in-out' },
          { name: 'lolipop-glide', duration: '2.8s', timing: 'ease-in-out' },
          { name: 'lolipop-squeeze', duration: '1.1s', timing: 'ease-in-out' },
          { name: 'lolipop-roll', duration: '2.3s', timing: 'ease-in-out' },
          { name: 'lolipop-wave', duration: '1.7s', timing: 'ease-in-out' },
          { name: 'lolipop-bob', duration: '0.9s', timing: 'ease-in-out' },
          { name: 'lolipop-sway', duration: '1.5s', timing: 'ease-in-out' },
          { name: 'lolipop-elastic', duration: '2.5s', timing: 'ease-in-out' }
        ];
        
        let currentAnimationIndex = 0;
        let isPaused = false;
        let animationTimeout;
        
        function startRandomLolipopAnimation() {
          const lolipopIcon = document.getElementById('lolipopIcon');
          if (!lolipopIcon) return;
          
          function playRandomAnimation() {
            if (isPaused) return; // 如果暂停，不播放动画
            
            const animation = lolipopAnimations[currentAnimationIndex];
            lolipopIcon.style.animation = `${animation.name} ${animation.duration} ${animation.timing}`;
            
            currentAnimationIndex = (currentAnimationIndex + 1) % lolipopAnimations.length;
            
            // 设置下一个动画的延迟时间（随机1-3秒）
            const animationDuration = parseFloat(animation.duration) * 1000;
            const nextDelay = Math.random() * 2000 + 1000;
            
            animationTimeout = setTimeout(() => {
              if (!isPaused) {
                lolipopIcon.style.animation = 'none';
                setTimeout(() => {
                  playRandomAnimation();
                }, 100);
              }
            }, animationDuration + nextDelay);
          }
          
          // 点击lolipop图标暂停/继续动画
          lolipopIcon.addEventListener('click', () => {
            isPaused = !isPaused;
            
            if (isPaused) {
              // 暂停：清除动画和定时器
              lolipopIcon.style.animation = 'none';
              if (animationTimeout) {
                clearTimeout(animationTimeout);
              }
              lolipopIcon.style.opacity = '0.5'; // 降低透明度表示暂停状态
            } else {
              // 继续：恢复动画
              lolipopIcon.style.opacity = '0.7'; // 恢复透明度
              setTimeout(() => {
                playRandomAnimation();
              }, 100);
            }
          });
          
          // 开始第一个动画
          playRandomAnimation();
        }
        
        // 启动lolipop动画
        startRandomLolipopAnimation();
        
        // 初始化印章计数器关卡选择器
        const sealCounterLevel = document.getElementById('sealCounterLevel');
        if (sealCounterLevel && levelSelect) {
          // 复制关卡选项到印章计数器
          Array.from(levelSelect.options).forEach(option => {
            if (option.value) {
              const newOption = document.createElement('option');
              newOption.value = option.value;
              newOption.textContent = option.textContent;
              sealCounterLevel.appendChild(newOption);
            }
          });
        }
        
        // 印章计数器关卡选择变化
        sealCounterLevel.addEventListener('change', () => {
          const confirmBtn = document.getElementById('confirmSealLevel');
          const hasValidSelection = sealCounterLevel.value && sealCounterLevel.value !== '';
          
          if (hasValidSelection) {
            confirmBtn.disabled = false;
            confirmBtn.style.backgroundColor = '';
            confirmBtn.style.color = '';
            confirmBtn.style.cursor = '';
          } else {
            confirmBtn.disabled = true;
            confirmBtn.style.backgroundColor = '#ccc';
            confirmBtn.style.color = '#666';
            confirmBtn.style.cursor = 'not-allowed';
          }
          
          // 重新选择关卡时自动清零
          if (sealCounterLevel.value) {
            sealCounter = 0;
            selectedSealLevel = '';
            window.selectedSealLevel = ''; // 同步清空全局变量
            selectedGrowthType = '';
            originalSealValue = 0;
            
            document.getElementById('sealCounterDisplay').style.display = 'none';
            document.getElementById('sealCounterNumber').textContent = '0';
            document.getElementById('sealValueChange').textContent = '0 → 0';
          }
        });
        
        // 确认关卡按钮
        document.getElementById('confirmSealLevel').addEventListener('click', () => {
          if (sealCounterLevel.value) {
            selectedSealLevel = sealCounterLevel.value;
            window.selectedSealLevel = selectedSealLevel; // 同步到全局变量
            // 获取增长类型
            selectedGrowthType = getGrowthTypeForLevel(selectedSealLevel);
            // 获取原始盗印值
            originalSealValue = getCurrentSealValue();
            
            // 直接显示印章计数显示区域
            document.getElementById('sealCounterDisplay').style.display = 'block';
            if (window.updateSealCounterDisplay) {
              window.updateSealCounterDisplay();
            }
          }
        });
        
        // 重置按钮
        document.getElementById('resetSealCounter').addEventListener('click', () => {
          sealCounter = 0;
          selectedSealLevel = '';
          window.selectedSealLevel = ''; // 同步清空全局变量
          selectedGrowthType = '';
          originalSealValue = 0;
          
          sealCounterLevel.value = '';
          document.getElementById('confirmSealLevel').disabled = true;
          document.getElementById('sealCounterDisplay').style.display = 'none';
          document.getElementById('sealCounterNumber').textContent = '0';
          document.getElementById('sealValueChange').textContent = '0 → 0';
        });
        
        // 木鱼点击事件
        document.getElementById('woodenFish').addEventListener('click', () => {
          if (selectedSealLevel) {
            sealCounter++;
            window.updateSealCounterDisplay();
            window.updateSealValue();
            
            // 添加点击动画
            const woodenFish = document.getElementById('woodenFish');
            woodenFish.classList.add('hit');
            setTimeout(() => {
              woodenFish.classList.remove('hit');
            }, 300);
          }
        });
        
        // 获取关卡的增长类型
        function getGrowthTypeForLevel(level) {
          const levelIndex = keyOrder.indexOf(level);
          if (levelIndex === -1) return '普通盗印';
          
          // 使用与关卡目标分模块相同的逻辑来获取增长类型
          return resolveTypeAtIndex('d', levelIndex);
        }
        
        // 获取当前盗印值
        function getCurrentSealValue() {
          const all = computeRecommendedAll();
          const levelData = all[selectedSealLevel];
          return levelData ? levelData.actualD || 0 : 0;
        }
        
        // 更新关卡目标分模块中对应关卡的盗印值
        function updateLevelTargetDisplay(level, newValue) {
          // 更新levelsState中的手动值
          levelsState[level] = levelsState[level] || {};
          levelsState[level].manuD = newValue.toString();
          
          // 重新渲染关卡目标分模块，这会重新计算所有关卡的推荐值
          renderPage5();
          
          // 如果当前选择的关卡是同一个，也要更新数值设置模块
          if (document.getElementById('levelSelect').value === level) {
            document.getElementById('daoyin').value = newValue.toFixed(6);
            updateStampDisplay();
          }
        }
        
        // 更新计数器显示
        window.updateSealCounterDisplay = function() {
          document.getElementById('sealCounterNumber').textContent = sealCounter;
          document.getElementById('currentSealLevel').textContent = selectedSealLevel;
          document.getElementById('currentGrowthType').textContent = selectedGrowthType;
        };
        
        // 显示印章计数提示
        function showSealCounterNotification() {
          // 创建提示元素
          const notification = document.createElement('div');
          notification.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            background: #ff6b6b;
            color: white;
            padding: 12px 16px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 1000;
            font-size: 14px;
            max-width: 300px;
            animation: slideIn 0.3s ease-out;
          `;
          notification.innerHTML = `
            <div style="font-weight: bold; margin-bottom: 4px;">⚠️ 增长类型已调整</div>
            <div>建议核对重新计算印章计数</div>
          `;
          
          // 添加动画样式
          if (!document.getElementById('notification-styles')) {
            const style = document.createElement('style');
            style.id = 'notification-styles';
            style.textContent = `
              @keyframes slideIn {
                from { transform: translateX(100%); opacity: 0; }
                to { transform: translateX(0); opacity: 1; }
              }
            `;
            document.head.appendChild(style);
          }
          
          // 添加到页面
          document.body.appendChild(notification);
          
          // 3秒后自动移除
          setTimeout(() => {
            notification.style.animation = 'slideIn 0.3s ease-out reverse';
            setTimeout(() => {
              if (notification.parentNode) {
                notification.parentNode.removeChild(notification);
              }
            }, 300);
          }, 3000);
        }
        
        // 更新盗印值显示
        window.updateSealValue = function() {
          const multiplier = window.getMultiplierForGrowthType(selectedGrowthType);
          const newValue = originalSealValue * Math.pow(multiplier, sealCounter);
          
          // 格式化数字显示，大于10000时使用中国大数字单位
          const formatNumberForDisplay = (num) => {
            if (num >= 10000) {
              return formatChinaJiLocal(num.toString(), 2);
            }
            return num.toFixed(2);
          };
          
          const originalDisplay = formatNumberForDisplay(originalSealValue);
          const newDisplay = formatNumberForDisplay(newValue);
          document.getElementById('sealValueChange').textContent = `${originalDisplay} → ${newDisplay}`;
          
          // 更新关卡目标分模块中对应关卡的盗印值
          updateLevelTargetDisplay(selectedSealLevel, newValue);
        };
        
        // 根据增长类型获取倍数
        window.getMultiplierForGrowthType = function(growthType) {
          switch (growthType) {
            case '膨胀盗印':
            case '膨胀盗印吃卡维':
              return 1.3 * 1.3; // 1.69
            case '普通盗印':
              return 1.3;
            case '天使盗印':
              return 1.6;
            default:
              return 1.3;
          }
        };

        // 初始化配置区块拖拽调整宽度
        const grid = document.getElementById('blocksGrid');
        let dragging = null; // { block, startX, startBasis, side }
        function onMove(e){
          if (!dragging) return;
          const dx = e.clientX - dragging.startX;
          const block = dragging.block;
          const containerWidth = grid.getBoundingClientRect().width;
          let basisPx = dragging.startBasis;
          basisPx += (dragging.side === 'right' ? dx : -dx);
          const minPx = 180; // 最小宽度
          const maxPx = containerWidth - 180; // 防止过大
          basisPx = Math.max(minPx, Math.min(maxPx, basisPx));
          block.style.flex = `0 0 ${basisPx}px`;
        }
        function onUp(){
          if (!dragging) return;
          document.removeEventListener('mousemove', onMove);
          document.removeEventListener('mouseup', onUp);
          dragging = null;
        }
        grid?.querySelectorAll('.config-block .resize-handle').forEach(h => {
          h.addEventListener('mousedown', (e)=>{
            const block = e.currentTarget.closest('.config-block');
            if (!block) return;
            const rect = block.getBoundingClientRect();
            const side = e.currentTarget.getAttribute('data-resize') === 'left' ? 'left' : 'right';
            dragging = {
              block,
              startX: e.clientX,
              startBasis: rect.width,
              side
            };
            document.addEventListener('mousemove', onMove);
            document.addEventListener('mouseup', onUp);
            e.preventDefault();
          });
        });
      });
      
    </script>

    <!-- 音乐播放器 -->
    <div id="music-player" class="music-player">
      <div class="music-player-header">
        <div class="music-info">
          <div class="album-cover" id="album-cover">
            <img id="cover-image" src="" alt="专辑封面">
          </div>
          <div class="song-info">
            <div class="song-title">Loading...</div>
            <div class="song-artist">16Pome</div>
          </div>
        </div>
        <div class="music-controls">
          <button id="play-pause-btn" class="control-btn" title="播放/暂停">▶️</button>
          <button id="toggle-lyrics-btn" class="control-btn" title="歌词显示/隐藏">📝</button>
          <button id="toggle-player-btn" class="control-btn" title="展开/折叠">🔽</button>
          <button id="close-player-btn" class="control-btn" title="关闭播放器">✖</button>
        </div>
      </div>
      
      <div class="music-player-body" id="music-player-body" style="display: none;">
        <div class="progress-container">
          <div class="progress-bar" id="progress-bar">
            <div class="progress-fill" id="progress-fill"></div>
          </div>
          <div class="time-display">
            <span id="current-time">0:00</span>
            <span id="total-time">0:00</span>
          </div>
        </div>
        
        <div class="volume-container">
          <span>🔊</span>
          <input type="range" id="volume-slider" min="0" max="100" value="50">
        </div>
        
        <div class="lyrics-container" id="lyrics-container" style="display: none;">
          <div class="lyrics-content" id="lyrics-content">
            <!-- 歌词内容将通过JavaScript动态加载 -->
          </div>
        </div>
      </div>
      <div id="music-resizer" class="music-resizer" title="拖拽调整宽度"></div>
      
      <audio id="audio-player" preload="metadata">
        <source src="src/assets/music/人生也许.MP3" type="audio/mpeg">
        您的浏览器不支持音频播放。
      </audio>
    </div>

    <!-- 最小化圆形入口 -->
    <div id="music-mini" class="music-mini" title="打开播放器">🎵</div>

    <style>
      /* 音乐播放器样式 */
      .music-player {
        position: fixed;
        bottom: 20px;
        right: 20px;
        width: 520px;
        max-width: calc(100vw - 40px);
        background: linear-gradient(135deg, var(--primary-color, #667eea) 0%, var(--secondary-color, #764ba2) 100%);
        border-radius: 15px;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.1);
        z-index: 1000;
        transition: all 0.3s ease;
        font-family: 'Microsoft YaHei', sans-serif;
      }
      /* 未保存修改的高亮样式 */
      .modified-input {
        outline: 2px solid #f59e0b; /* amber-500 */
        background: rgba(245, 158, 11, 0.08);
      }

      /* 最小化圆形图标按钮 */
      .music-mini {
        position: fixed;
        bottom: 20px;
        right: 20px;
        width: 54px;
        height: 54px;
        border-radius: 50%;
        background: linear-gradient(135deg, var(--primary-color, #667eea) 0%, var(--secondary-color, #764ba2) 100%);
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        display: none;
        align-items: center;
        justify-content: center;
        color: #fff;
        font-size: 22px;
        cursor: pointer;
        z-index: 1000;
        border: 1px solid rgba(255,255,255,0.2);
        transition: transform 0.2s ease, opacity 0.2s ease;
        opacity: 0.7;
      }
      .music-mini:hover { transform: scale(1.06); opacity: 1; }

      /* 左侧拖拽手柄，用于调整播放器宽度 */
      .music-resizer {
        position: absolute;
        top: 0;
        left: 0;
        width: 10px;
        height: 100%;
        cursor: ew-resize;
        background: linear-gradient(to right, rgba(255,255,255,0.18), rgba(255,255,255,0));
        border-top-left-radius: 15px;
        border-bottom-left-radius: 15px;
      }

      .music-player-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 15px;
        color: white;
      }

      .music-info {
        display: flex;
        align-items: center;
        gap: 12px;
        flex: 1;
      }

      .album-cover {
        width: 50px;
        height: 50px;
        border-radius: 50%;
        overflow: hidden;
        position: relative;
        background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
        animation: rotate 10s linear infinite;
        animation-play-state: paused;
      }

      .album-cover.playing {
        animation-play-state: running;
      }

      .album-cover img {
        width: 100%;
        height: 100%;
        object-fit: cover;
        border-radius: 50%;
      }

      @keyframes rotate {
        from { transform: rotate(0deg); }
        to { transform: rotate(360deg); }
      }

      .song-info {
        flex: 1;
      }

      .song-title {
        font-size: 14px;
        font-weight: bold;
        margin-bottom: 2px;
      }

      .song-artist {
        font-size: 12px;
        opacity: 0.8;
      }

      .music-controls {
        display: flex;
        gap: 8px;
        align-items: center;
      }

      /* 歌曲选择器样式，适配页面风格 */
      #music-select {
        appearance: none;
        background: rgba(255, 255, 255, 0.18);
        color: #fff;
        border: 1px solid rgba(255, 255, 255, 0.25);
        border-radius: 8px;
        padding: 6px 10px;
        font-size: 12px;
        outline: none;
        transition: all 0.2s ease;
      }
      #music-select:hover {
        background: rgba(255, 255, 255, 0.28);
        border-color: rgba(255, 255, 255, 0.4);
      }
      #music-select option {
        color: #111;
        background: #fff;
      }

      .control-btn {
        background: rgba(255, 255, 255, 0.2);
        border: none;
        border-radius: 50%;
        width: 35px;
        height: 35px;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all 0.2s ease;
        font-size: 14px;
      }

      .control-btn:hover {
        background: rgba(255, 255, 255, 0.3);
        transform: scale(1.1);
      }

      .music-player-body {
        padding: 0 15px 15px;
        color: white;
      }

      .progress-container {
        margin-bottom: 15px;
      }

      .progress-bar {
        width: 100%;
        height: 4px;
        background: rgba(255, 255, 255, 0.3);
        border-radius: 2px;
        cursor: pointer;
        margin-bottom: 8px;
      }

      .progress-fill {
        height: 100%;
        background: linear-gradient(90deg, var(--accent-color, #ff6b6b), var(--highlight-color, #4ecdc4));
        border-radius: 2px;
        width: 0%;
        transition: width 0.1s ease;
      }

      .time-display {
        display: flex;
        justify-content: space-between;
        font-size: 12px;
        opacity: 0.8;
      }

      .volume-container {
        display: flex;
        align-items: center;
        gap: 10px;
        margin-bottom: 15px;
      }

      .volume-container input[type="range"] {
        flex: 1;
        height: 4px;
        background: rgba(255, 255, 255, 0.3);
        border-radius: 2px;
        outline: none;
        cursor: pointer;
      }

      .volume-container input[type="range"]::-webkit-slider-thumb {
        appearance: none;
        width: 12px;
        height: 12px;
        background: white;
        border-radius: 50%;
        cursor: pointer;
      }

      .lyrics-container {
        max-height: 200px;
        overflow-y: auto;
        background: rgba(0, 0, 0, 0.2);
        border-radius: 8px;
        padding: 10px;
      }

      .lyrics-content {
        font-size: 13px;
        line-height: 1.6;
        text-align: center;
      }

      .lyrics-content .verse {
        margin-bottom: 8px;
        opacity: 0.7;
      }

      .lyrics-content .verse.empty {
        height: 16px;
        margin-bottom: 4px;
        opacity: 0;
      }

      .lyrics-content .verse.active {
        opacity: 1;
        font-weight: bold;
        color: var(--accent-color, #ff6b6b);
        background: rgba(255, 255, 255, 0.15);
        border-radius: 8px;
        padding: 4px 8px;
        margin: 2px 0;
        transform: scale(1.05);
      }

      .lyrics-content .verse.highlight {
        background: rgba(var(--accent-color-rgb, 255, 107, 107), 0.3);
        padding: 2px 6px;
        border-radius: 4px;
      }

      /* 滚动条样式 */
      .lyrics-container::-webkit-scrollbar {
        width: 4px;
      }

      .lyrics-container::-webkit-scrollbar-track {
        background: rgba(255, 255, 255, 0.1);
        border-radius: 2px;
      }

      .lyrics-container::-webkit-scrollbar-thumb {
        background: rgba(255, 255, 255, 0.3);
        border-radius: 2px;
      }

      .lyrics-container::-webkit-scrollbar-thumb:hover {
        background: rgba(255, 255, 255, 0.5);
      }

      /* 响应式设计 */
      @media (max-width: 768px) {
        .music-player {
          width: calc(100vw - 40px);
          right: 20px;
          left: 20px;
        }
      }
    </style>

    <script>
      // 音乐播放器功能
      (function() {
        const audio = document.getElementById('audio-player');
        const playPauseBtn = document.getElementById('play-pause-btn');
        const toggleLyricsBtn = document.getElementById('toggle-lyrics-btn');
        const togglePlayerBtn = document.getElementById('toggle-player-btn');
        const closePlayerBtn = document.getElementById('close-player-btn');
        const musicMini = document.getElementById('music-mini');
        const musicResizer = document.getElementById('music-resizer');
        const musicPlayerBody = document.getElementById('music-player-body');
        const lyricsContainer = document.getElementById('lyrics-container');
        const progressBar = document.getElementById('progress-bar');
        const progressFill = document.getElementById('progress-fill');
        const currentTimeEl = document.getElementById('current-time');
        const totalTimeEl = document.getElementById('total-time');
        const volumeSlider = document.getElementById('volume-slider');
        const albumCover = document.getElementById('album-cover');
          const coverImage = document.getElementById('cover-image');
          const lyricsContent = document.getElementById('lyrics-content');
          const songTitleEl = document.querySelector('.song-title');
          const controlsEl = document.querySelector('.music-controls');

          // 播放模式按钮与歌曲选择器（UI动态插入）
          const playModeBtn = document.createElement('button');
          playModeBtn.className = 'control-btn';
          playModeBtn.id = 'play-mode-btn';
          playModeBtn.title = '播放模式：单曲(🔂)/列表(🔁)/随机(🔀)';
          controlsEl.appendChild(playModeBtn);

          const musicSelect = document.createElement('select');
          musicSelect.id = 'music-select';
          musicSelect.style.cssText = 'background: rgba(255,255,255,0.2); color:#fff; border:none; border-radius:6px; padding:4px 6px; max-width:140px;';
          controlsEl.appendChild(musicSelect);

        // 护身符图片列表
        const amuletImages = [
          'fu_0001.png', 'fu_0002.png', 'fu_0004.png', 'fu_0006.png', 'fu_0007.png', 'fu_0009.png',
          'fu_0011.png', 'fu_0012.png', 'fu_0013.png', 'fu_0014.png', 'fu_0016.png', 'fu_0017.png',
          'fu_0018.png', 'fu_0019.png', 'fu_0020.png', 'fu_0023.png', 'fu_0024.png', 'fu_0025.png',
          'fu_0027.png', 'fu_0028.png', 'fu_0029.png', 'fu_0030.png', 'fu_0031.png', 'fu_0032.png',
          'fu_0033.png', 'fu_0035.png', 'fu_0036.png', 'fu_0037.png', 'fu_0038.png', 'fu_0040.png',
          'fu_0042.png', 'fu_0046.png', 'fu_0047.png', 'fu_0049.png', 'fu_0058.png', 'fu_0064.png',
          'fu_0065.png', 'fu_0066.png', 'fu_0067.png', 'fu_0071.png', 'fu_0074.png', 'fu_0075.png',
          'fu_0076.png', 'fu_0077.png', 'fu_0079.png', 'fu_0080.png', 'fu_0089.png', 'fu_0090.png',
          'fu_0091.png', 'fu_0092.png', 'fu_0093.png', 'fu_0094.png', 'fu_0095.png', 'fu_0096.png',
          'fu_0097.png', 'fu_0098.png', 'fu_0099.png', 'fu_0100.png', 'fu_0101.png', 'fu_0102.png',
          'fu_0105.png', 'fu_0106.png', 'fu_0108.png', 'fu_0110.png', 'fu_0111.png', 'fu_0112.png',
          'fu_0113.png', 'fu_0115.png', 'fu_0116.png', 'fu_0118.png', 'fu_0119.png', 'fu_0120.png',
          'fu_0122.png', 'fu_0124.png', 'fu_0126.png', 'fu_0127.png', 'fu_0128.png', 'fu_0129.png',
          'fu_0130.png', 'fu_0131.png', 'fu_0132.png', 'fu_0133.png', 'fu_0134.png', 'fu_0135.png',
          'fu_0136.png', 'fu_0137.png', 'fu_0138.png', 'fu_0139.png', 'fu_0141.png', 'fu_0142.png',
          'fu_0143.png', 'fu_0144.png', 'fu_0145.png', 'fu_0146.png', 'fu_0147.png', 'fu_0148.png',
          'fu_0149.png', 'fu_0151.png', 'fu_0152.png', 'fu_0153.png', 'fu_0154.png', 'fu_0156.png',
          'fu_0157.png', 'fu_0158.png', 'fu_0159.png', 'fu_0160.png', 'fu_0161.png', 'fu_0162.png',
          'fu_0163.png', 'fu_0164.png', 'fu_0165.png', 'fu_0166.png', 'fu_0167.png', 'fu_0168.png',
          'fu_0169.png', 'fu_0170.png', 'fu_0171.png', 'fu_0172.png', 'fu_0173.png', 'fu_0174.png',
          'fu_0175.png', 'fu_0176.png', 'fu_0177.png', 'fu_0178.png', 'fu_0179.png', 'fu_0180.png',
          'fu_0181.png', 'fu_0182.png', 'fu_0183.png', 'fu_0184.png', 'fu_0185.png', 'fu_0186.png',
          'fu_0187.png', 'fu_0188.png', 'fu_0189.png', 'fu_0190.png', 'fu_0191.png', 'fu_0192.png',
          'fu_0193.png', 'fu_0194.png', 'fu_0195.png'
        ];

        // 歌词数据 - 从LRC文件解析
        let lyrics = [];
        
        // 解析LRC文件
          async function parseLRCFile() {
          try {
             // 基于当前音频源尝试加载同名 .lrc 文件
             const currentSource = audio.querySelector('source')?.getAttribute('src') || '';
             const base = currentSource ? currentSource.replace(/\.[^.]+$/, '') : 'src/assets/music/人生也许';
             // 先询问后端是否存在 LRC，避免直接 404
             const headResp = await fetch(`/api/music/has-lrc?base=${encodeURIComponent(base)}`);
             const headJson = await headResp.json().catch(()=>({ exists:false }));
             if (!headJson.exists) {
               lyrics = [ { time: 0, text: '该音乐暂无歌词', type: 'verse' } ];
               return;
             }
             const lrcPath = `${base}.lrc`;
             const response = await fetch(lrcPath, { cache: 'no-store' });
             if (!response.ok) throw new Error('LRC not found');
            const lrcText = await response.text();
            const lines = lrcText.split('\n');
            
            lyrics = [];
            for (const line of lines) {
              const match = line.match(/\[(\d{2}):(\d{2})\.(\d{2})\](.*)/);
              if (match) {
                const minutes = parseInt(match[1]);
                const seconds = parseInt(match[2]);
                const centiseconds = parseInt(match[3]);
                const time = minutes * 60 + seconds + centiseconds / 100;
                const text = match[4].trim();
                
                // 保留空行，用特殊标记
                lyrics.push({
                  time: time,
                  text: text || ' ', // 空行用空格代替
                  type: text.includes('【') ? 'section' : (text ? 'verse' : 'empty')
                });
              }
            }
            
            // 按时间排序
            lyrics.sort((a, b) => a.time - b.time);
            //console.log('LRC歌词加载完成:', lyrics.length, '行');
            } catch (error) {
             // 无对应歌词文件
             lyrics = [ { time: 0, text: '该音乐暂无歌词', type: 'verse' } ];
          }
        }

        let isPlaying = false;
        let currentLyricIndex = 0;
        let currentThemeColors = null; // 存储当前主题的固定颜色组合

        // 更新音乐播放器主题色
        function updateMusicPlayerTheme() {
          const musicPlayer = document.getElementById('music-player');
          if (!musicPlayer) return;
          
          // 获取当前body或html上的主题类
          const bodyClasses = document.body.className;
          const htmlClasses = document.documentElement.className;
          const allClasses = bodyClasses + ' ' + htmlClasses;
          
          //console.log('当前主题类:', allClasses);
          
          // 定义每个主题的多个颜色组合选项
          const themeColorOptions = {
            'theme-16QwQ': [
              { primary: '#73CCFF', secondary: '#5BB3FF', accent: '#ACF06D', highlight: '#E8A469' },
              { primary: '#5BB3FF', secondary: '#73CCFF', accent: '#E8A469', highlight: '#ACF06D' },
              { primary: '#ACF06D', secondary: '#E8A469', accent: '#73CCFF', highlight: '#5BB3FF' }
            ],
            'theme-buxingshx': [
              { primary: '#00E874', secondary: '#00CC66', accent: '#00B0F0', highlight: '#B6FF47' },
              { primary: '#00CC66', secondary: '#00E874', accent: '#B6FF47', highlight: '#00B0F0' },
              { primary: '#00B0F0', secondary: '#B6FF47', accent: '#00E874', highlight: '#00CC66' }
            ],
            'theme-life': [
              { primary: '#A5EAFF', secondary: '#8DD8FF', accent: '#9EC4F6', highlight: '#BEFFF8' },
              { primary: '#8DD8FF', secondary: '#A5EAFF', accent: '#BEFFF8', highlight: '#9EC4F6' },
              { primary: '#9EC4F6', secondary: '#BEFFF8', accent: '#A5EAFF', highlight: '#8DD8FF' }
            ],
            'theme-purple': [
              { primary: '#65BFBE', secondary: '#4A9B9A', accent: '#DEEDA1', highlight: '#BDE031' },
              { primary: '#4A9B9A', secondary: '#65BFBE', accent: '#BDE031', highlight: '#DEEDA1' },
              { primary: '#DEEDA1', secondary: '#BDE031', accent: '#65BFBE', highlight: '#4A9B9A' }
            ],
            'theme-rainbow': [
              { primary: '#FFB78C', secondary: '#FFA066', accent: '#FFF08C', highlight: '#BBFF8C' },
              { primary: '#FFA066', secondary: '#FFB78C', accent: '#BBFF8C', highlight: '#FFF08C' },
              { primary: '#FFF08C', secondary: '#BBFF8C', accent: '#FFB78C', highlight: '#FFA066' }
            ],
            'theme-wonderful': [
              { primary: '#FF3B3E', secondary: '#E03437', accent: '#FF8657', highlight: '#FFBA70' },
              { primary: '#E03437', secondary: '#FF3B3E', accent: '#FFBA70', highlight: '#FF8657' },
              { primary: '#FF8657', secondary: '#FFBA70', accent: '#FF3B3E', highlight: '#E03437' }
            ],
            'theme-16yyds': [
              { primary: '#95a3f3', secondary: '#D1F33A', accent: '#C6DC74', highlight: '#A8BB92' },
              { primary: '#D1F33A', secondary: '#95a3f3', accent: '#A8BB92', highlight: '#C6DC74' },
              { primary: '#C6DC74', secondary: '#A8BB92', accent: '#95a3f3', highlight: '#D1F33A' }
            ],
            'default': [
              { primary: '#9AA3A0', secondary: '#6F7976', accent: '#C4B7A6', highlight: '#C4B7A6' },
              { primary: '#6F7976', secondary: '#9AA3A0', accent: '#C4B7A6', highlight: '#9AA3A0' },
              { primary: '#C4B7A6', secondary: '#C4B7A6', accent: '#9AA3A0', highlight: '#6F7976' }
            ]
          };
          
          // 检测当前主题并获取颜色选项
          let colorOptions = themeColorOptions.default;
          let currentTheme = 'default';
          
          for (const themeClass in themeColorOptions) {
            if (themeClass !== 'default' && allClasses.includes(themeClass)) {
              colorOptions = themeColorOptions[themeClass];
              currentTheme = themeClass;
              break;
            }
          }
          
          // 检查是否需要重新随机选择颜色（主题变化或首次加载）
          const lastTheme = localStorage.getItem('musicPlayerLastTheme');
          if (lastTheme !== currentTheme || !currentThemeColors) {
            // 随机选择一个颜色组合
            const randomIndex = Math.floor(Math.random() * colorOptions.length);
            currentThemeColors = colorOptions[randomIndex];
            localStorage.setItem('musicPlayerLastTheme', currentTheme);
            localStorage.setItem('musicPlayerColors', JSON.stringify(currentThemeColors));
            //console.log('主题变化，重新随机选择颜色组合:', currentTheme, randomIndex);
          } else {
            // 使用存储的颜色组合
            const storedColors = localStorage.getItem('musicPlayerColors');
            if (storedColors) {
              currentThemeColors = JSON.parse(storedColors);
            }
          }
          
          // 改善对比度 - 为歌词高亮选择更好的颜色
          const { primary, secondary, accent, highlight } = currentThemeColors;
          
          // 计算颜色的亮度，选择对比度更好的颜色作为歌词高亮色
          const getLuminance = (hex) => {
            const rgb = hexToRgb(hex);
            if (!rgb) return 0;
            const { r, g, b } = rgb;
            return (0.299 * r + 0.587 * g + 0.114 * b) / 255;
          };
          
          // 选择对比度最好的颜色作为歌词高亮色
          const colors = [primary, secondary, accent, highlight];
          let bestContrastColor = accent;
          let bestContrast = 0;
          
          colors.forEach(color => {
            const luminance = getLuminance(color);
            const contrast = Math.abs(luminance - 0.5); // 距离中灰度的距离
            if (contrast > bestContrast) {
              bestContrast = contrast;
              bestContrastColor = color;
            }
          });
          
          // 计算背景亮度，决定使用深色还是亮色文字
          const primaryLuminance = getLuminance(primary);
          const secondaryLuminance = getLuminance(secondary);
          const backgroundLuminance = (primaryLuminance + secondaryLuminance) / 2;
          
          let enhancedAccent;
          
          // 根据背景亮度选择固定的高对比度颜色
          if (backgroundLuminance > 0.5) {
            // 背景较亮，使用固定的深色文字确保对比度
            enhancedAccent = '#212596'; // 青云蓝
          } else {
            // 背景较暗，使用固定的亮色文字确保对比度
            enhancedAccent = '#FFFFFF'; // 纯白色
          }
          
          //console.log('背景亮度:', backgroundLuminance, '歌词使用固定颜色:', enhancedAccent);
          
          //
          
          // 更新CSS变量
          musicPlayer.style.setProperty('--primary-color', primary);
          musicPlayer.style.setProperty('--secondary-color', secondary);
          musicPlayer.style.setProperty('--accent-color', enhancedAccent);
          musicPlayer.style.setProperty('--highlight-color', highlight);
          
          // 处理RGB颜色用于rgba
          const accentRgb = hexToRgb(enhancedAccent);
          if (accentRgb) {
            musicPlayer.style.setProperty('--accent-color-rgb', `${accentRgb.r}, ${accentRgb.g}, ${accentRgb.b}`);
          }
        }
        
        // 十六进制颜色转RGB
        function hexToRgb(hex) {
          const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
          return result ? {
            r: parseInt(result[1], 16),
            g: parseInt(result[2], 16),
            b: parseInt(result[3], 16)
          } : null;
        }

        // 初始化随机封面
        function setRandomCover() {
          const randomImage = amuletImages[Math.floor(Math.random() * amuletImages.length)];
          coverImage.src = `src/assets/amulet/${randomImage}`;
        }

        // 格式化时间
        function formatTime(seconds) {
          const mins = Math.floor(seconds / 60);
          const secs = Math.floor(seconds % 60);
          return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        // 更新进度条
        function updateProgress() {
          const progress = (audio.currentTime / audio.duration) * 100;
          progressFill.style.width = progress + '%';
          currentTimeEl.textContent = formatTime(audio.currentTime);
        }

        // 更新歌词高亮
        function updateLyrics() {
          const currentTime = audio.currentTime;
          
          // 找到当前应该高亮的歌词
          let activeIndex = -1;
          for (let i = 0; i < lyrics.length; i++) {
            if (lyrics[i].time <= currentTime) {
              activeIndex = i;
            } else {
              break;
            }
          }

          if (activeIndex !== currentLyricIndex) {
            currentLyricIndex = activeIndex;
            
            // 移除所有高亮
            const verseElements = lyricsContent.querySelectorAll('.verse');
            verseElements.forEach(el => el.classList.remove('active', 'highlight'));
            
            // 高亮当前歌词
            if (activeIndex >= 0 && verseElements[activeIndex]) {
              verseElements[activeIndex].classList.add('active');
              
              // 滚动到当前歌词
              verseElements[activeIndex].scrollIntoView({
                behavior: 'smooth',
                block: 'center'
              });
            }
          }
        }

        // 渲染歌词
        function renderLyrics() {
          lyricsContent.innerHTML = lyrics.map(lyric => {
            let className = 'verse';
            if (lyric.type === 'section') {
              className = 'verse section';
            } else if (lyric.type === 'empty') {
              className = 'verse empty';
            }
            return `<div class="${className}">${lyric.text}</div>`;
          }).join('');
        }

        // 播放/暂停
        function togglePlayPause() {
          if (isPlaying) {
            audio.pause();
            playPauseBtn.textContent = '▶️';
            albumCover.classList.remove('playing');
          } else {
            audio.play();
            playPauseBtn.textContent = '⏸️';
            albumCover.classList.add('playing');
          }
          isPlaying = !isPlaying;
        }

        // 切换歌词显示
        function toggleLyrics() {
          const isVisible = lyricsContainer.style.display !== 'none';
          lyricsContainer.style.display = isVisible ? 'none' : 'block';
          toggleLyricsBtn.textContent = isVisible ? '📝' : '📖';
          
          // 如果歌词显示且播放器未展开，自动展开播放器
          if (!isVisible && musicPlayerBody.style.display === 'none') {
            musicPlayerBody.style.display = 'block';
            togglePlayerBtn.textContent = '🔼';
          }
        }

        // 切换播放器展开/折叠
        function togglePlayer() {
          const isExpanded = musicPlayerBody.style.display !== 'none';
          musicPlayerBody.style.display = isExpanded ? 'none' : 'block';
          togglePlayerBtn.textContent = isExpanded ? '🔽' : '🔼';
        }

        // 点击进度条跳转
        function seekTo(event) {
          const rect = progressBar.getBoundingClientRect();
          const clickX = event.clientX - rect.left;
          const percentage = clickX / rect.width;
          const newTime = percentage * audio.duration;
          audio.currentTime = newTime;
        }

        // 初始化函数
        async function initializeMusicPlayer() {
          setRandomCover();
          await parseLRCFile(); // 加载LRC歌词
          renderLyrics();
            audio.volume = 0.5;
            updateMusicPlayerTheme(); // 更新主题色
            
            // 播放模式：0 单曲循环，1 列表循环，2 随机
            let playMode = 1;
            // 交换图标：单曲🔂，列表🔁，随机🔀
            const modeIcons = ['🔂','🔁','🔀'];
            const updateModeIcon = () => { playModeBtn.textContent = modeIcons[playMode]; };
            updateModeIcon();
            playModeBtn.addEventListener('click', () => { 
              playMode = (playMode + 1) % 3; 
              updateModeIcon(); 
              // 同步更新悬停提示
              const titles = ['播放模式：单曲循环 (🔂)','播放模式：列表循环 (🔁)','播放模式：随机播放 (🔀)'];
              playModeBtn.title = titles[playMode];
            });
            
            // 设置事件监听器（确保DOM元素已准备好）
          playPauseBtn.addEventListener('click', togglePlayPause);
          toggleLyricsBtn.addEventListener('click', toggleLyrics);
          togglePlayerBtn.addEventListener('click', togglePlayer);
          if (closePlayerBtn) closePlayerBtn.addEventListener('click', () => {
            const player = document.getElementById('music-player');
            if (!player || !musicMini) return;
            player.style.display = 'none';
            musicMini.style.display = 'flex';
          });
          if (musicMini) musicMini.addEventListener('click', () => {
            const player = document.getElementById('music-player');
            if (!player) return;
            player.style.display = 'block';
            musicMini.style.display = 'none';
          });
          progressBar.addEventListener('click', seekTo);

          // 读取并应用用户自定义宽度
          try {
            const savedWidth = localStorage.getItem('musicPlayerWidth');
            if (savedWidth) {
              const player = document.getElementById('music-player');
              if (player) player.style.width = savedWidth + 'px';
            }
          } catch(_) {}

          // 宽度拖拽调整
          if (musicResizer) {
            let resizing = false;
            let startX = 0;
            let startWidth = 0;
            const player = document.getElementById('music-player');
            const minWidth = 360; // 最小宽度
            const maxWidth = Math.max(window.innerWidth - 40, 480); // 保证不超屏

            const onMouseDown = (e) => {
              resizing = true;
              startX = e.clientX;
              startWidth = player ? player.offsetWidth : 0;
              document.body.style.cursor = 'ew-resize';
              e.preventDefault();
            };
            const onMouseMove = (e) => {
              if (!resizing || !player) return;
              // 左侧拖拽：鼠标左移应增大宽度，右移应减小宽度，仅改变宽度
              const delta = e.clientX - startX; // 鼠标右移为正、左移为负
              let newWidth = startWidth - delta;
              newWidth = Math.max(minWidth, Math.min(maxWidth, newWidth));
              player.style.width = newWidth + 'px';
            };
            const onMouseUp = () => {
              if (!resizing || !player) return;
              resizing = false;
              document.body.style.cursor = '';
              try { localStorage.setItem('musicPlayerWidth', parseInt(player.style.width, 10)); } catch(_) {}
            };
            musicResizer.addEventListener('mousedown', onMouseDown);
            window.addEventListener('mousemove', onMouseMove);
            window.addEventListener('mouseup', onMouseUp);
          }

          audio.addEventListener('timeupdate', () => {
            updateProgress();
            updateLyrics();
          });

          audio.addEventListener('loadedmetadata', () => {
            totalTimeEl.textContent = formatTime(audio.duration);
          });

            audio.addEventListener('ended', async () => {
              const options = Array.from(musicSelect.options);
              const curSrc = audio.querySelector('source')?.getAttribute('src');
              const norm = (s) => decodeURIComponent(String(s || '')).toLowerCase();
              const curIdx = options.findIndex(o => norm(o.value) === norm(curSrc));

              const playCurrent = async () => {
                audio.currentTime = 0;
                await parseLRCFile();
                renderLyrics();
                audio.play().catch(()=>{});
              };
              const playByIndex = async (idx) => {
                if (!options.length) return playCurrent();
                const safeIdx = (idx + options.length) % options.length;
                const src = options[safeIdx].value;
                const sourceEl = audio.querySelector('source');
                if (sourceEl) sourceEl.setAttribute('src', src);
                audio.load();
                await parseLRCFile();
                renderLyrics();
                songTitleEl.textContent = options[safeIdx].textContent;
                audio.play().catch(()=>{});
                musicSelect.value = src;
              };

              // 读取当前索引（更健壮：若匹配不到则用下拉已选项或0）
              const safeCurIdx = curIdx >= 0 ? curIdx : (musicSelect.selectedIndex >= 0 ? musicSelect.selectedIndex : 0);

              if (playMode === 0) {
                // 单曲循环
                await playCurrent();
              } else if (playMode === 1) {
                // 列表循环（顺序）
                const nextIdx = (safeCurIdx + 1) % (options.length || 1);
                await playByIndex(nextIdx);
              } else {
                // 随机
                if (!options.length) return playCurrent();
                let nextIdx = Math.floor(Math.random() * options.length);
                if (options.length > 1 && nextIdx === safeCurIdx) nextIdx = (nextIdx + 1) % options.length;
                await playByIndex(nextIdx);
              }
            });

          volumeSlider.addEventListener('input', (e) => {
            audio.volume = e.target.value / 100;
          });
          
           // 加载音乐列表并填充选择器（隐藏扩展名）
           try {
             const res = await fetch('/api/music/list');
             const data = await res.json();
             const files = Array.isArray(data.files) ? data.files : [];
             musicSelect.innerHTML = '';
             files.forEach(fn => {
               const opt = document.createElement('option');
               opt.value = `src/assets/music/${fn}`;
               opt.textContent = fn.replace(/\.[^.]+$/, '');
               musicSelect.appendChild(opt);
             });
             // 初始默认“人生也许”，异步加载完后再按顺序尝试播放其他
             const preferred = 'src/assets/music/人生也许.MP3';
             const sourceEl = audio.querySelector('source');
             if (sourceEl) sourceEl.setAttribute('src', preferred);
             audio.load();
             await parseLRCFile();
             renderLyrics();
             songTitleEl.textContent = '人生也许';
             // 同步下拉当前值，避免 ended 时找不到当前索引
             try { musicSelect.value = preferred; } catch(_) {}
             // 若用户手动播放后，根据播放模式处理 ended 逻辑
           } catch(_) {}

           // 切换歌曲
           musicSelect.addEventListener('change', async () => {
             const src = musicSelect.value;
             const sourceEl = audio.querySelector('source');
             if (sourceEl) sourceEl.setAttribute('src', src);
             audio.load();
             await parseLRCFile();
             renderLyrics();
             songTitleEl.textContent = musicSelect.options[musicSelect.selectedIndex]?.textContent || '';
             if (isPlaying) audio.play().catch(()=>{});
           });

           //console.log('音乐播放器初始化完成，等待用户手动播放');
          
          // 监听主题变化
          observeThemeChanges();
        }
        
        // 监听主题变化
        function observeThemeChanges() {
          // 创建MutationObserver监听DOM变化
          const observer = new MutationObserver((mutations) => {
            mutations.forEach((mutation) => {
              if (mutation.type === 'attributes' && 
                  (mutation.attributeName === 'style' || mutation.attributeName === 'class')) {
                // 主题可能发生变化，更新音乐播放器主题色
                //console.log('检测到主题变化:', mutation.attributeName);
                setTimeout(updateMusicPlayerTheme, 100);
              }
            });
          });
          
          // 监听document.documentElement的变化
          observer.observe(document.documentElement, {
            attributes: true,
            attributeFilter: ['style', 'class']
          });
          
          // 也监听body的变化
          observer.observe(document.body, {
            attributes: true,
            attributeFilter: ['style', 'class']
          });
          
          // 监听所有可能的主题切换元素
          const themeElements = document.querySelectorAll('[data-theme], .theme-switch, .color-picker, input[type="color"]');
          themeElements.forEach(el => {
            el.addEventListener('change', () => {
              //console.log('主题切换元素变化');
              setTimeout(updateMusicPlayerTheme, 200);
            });
            el.addEventListener('click', () => {
              //console.log('主题切换元素点击');
              setTimeout(updateMusicPlayerTheme, 200);
            });
          });
          
          // 监听所有按钮点击（可能包含主题切换）
          document.addEventListener('click', (e) => {
            if (e.target.tagName === 'BUTTON' || e.target.classList.contains('theme') || e.target.classList.contains('color')) {
              //('检测到可能的主题切换按钮点击');
              setTimeout(updateMusicPlayerTheme, 300);
            }
          });
          
          // 定期检查主题色变化（备用方案）
          setInterval(() => {
            updateMusicPlayerTheme();
          }, 1000); // 改为1秒检查一次
        }
        
        // 执行初始化
        initializeMusicPlayer();

        // 每15秒随机更换封面
        setInterval(setRandomCover, 15000);
      })();
    </script>
  </body>
  </html>


